diff --git a/fat32/src/mbr.rs b/fat32/src/mbr.rs
index d200c10..32459af 100644
--- a/fat32/src/mbr.rs
+++ b/fat32/src/mbr.rs
@@ -1,23 +1,39 @@
 use std::{fmt, io};
 
 use traits::BlockDevice;
+use std::mem::{transmute_copy, align_of};
+
 
 #[repr(C, packed)]
 #[derive(Copy, Clone)]
 pub struct CHS {
     // FIXME: Fill me in.
+    head: u8,
+    sector_and_high_cylinder: u8,
+    low_cylinder: u8,
 }
 
 #[repr(C, packed)]
 #[derive(Debug, Clone)]
 pub struct PartitionEntry {
     // FIXME: Fill me in.
+    boot_indicator: u8,
+    first_sector: CHS,
+    partition_type: u8, // 0xB or 0xC for FAT32
+    last_sector: CHS,
+    first_sector_lba: u32,
+    num_sectors: u32,
 }
 
 /// The master boot record (MBR).
-#[repr(C, packed)]
+// In some platforms, a u32 must be aligned to 4-byte boundary
+#[repr(C, align(512))]
 pub struct MasterBootRecord {
     // FIXME: Fill me in.
+    __r1: [u8; 436],
+    unique_disk_id: [u8; 10],
+    partitions: [PartitionEntry; 4],
+    magic: u16,
 }
 
 #[derive(Debug)]
@@ -40,12 +56,57 @@ impl MasterBootRecord {
     /// boot indicator. Returns `Io(err)` if the I/O error `err` occured while
     /// reading the MBR.
     pub fn from<T: BlockDevice>(mut device: T) -> Result<MasterBootRecord, Error> {
-        unimplemented!("MasterBootRecord::from()")
+        let mut buf = [0u8; 512];
+        let size = device.read_sector(0, &mut buf)?;
+        if size != 512 {
+            return Err(io::Error::new(
+                io::ErrorKind::UnexpectedEof,
+                "unable to read 512 bytes of MBR",
+            ).into());
+        } else {
+            let result: MasterBootRecord = unsafe { transmute_copy(&buf) };
+            if result.magic != 0xaa55 {
+                return Err(Error::BadSignature);
+            }
+
+            for i in 0..4usize {
+                if result.partitions[i].boot_indicator != 0x00
+                    && result.partitions[i].boot_indicator != 0x80
+                {
+                    return Err(Error::UnknownBootIndicator(i as u8));
+                }
+            }
+            return Ok(result);
+        }
+    }
+
+    pub fn first_vfat_partition_lba(&self) -> Option<u32> {
+        for i in 0..4 {
+            if self.partitions[i].partition_type == 0xB || self.partitions[i].partition_type == 0xC
+            {
+                return Some(self.partitions[i].first_sector_lba);
+            }
+        }
+        None
     }
 }
 
 impl fmt::Debug for MasterBootRecord {
     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
-        unimplemented!("MasterBootRecord::fmt()")
+        f.debug_struct("MasterBootRecord")
+            .field("partitions", &self.partitions)
+            .finish()
+    }
+}
+
+impl From<io::Error> for Error {
+    fn from(err: io::Error) -> Self {
+        Error::Io(err)
+    }
+}
+
+impl fmt::Debug for CHS {
+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
+        fmt.debug_struct("CHS").finish()
     }
 }
diff --git a/fat32/src/tests.rs b/fat32/src/tests.rs
index c896a42..a6f3ebb 100644
--- a/fat32/src/tests.rs
+++ b/fat32/src/tests.rs
@@ -8,9 +8,14 @@ use vfat::{Shared, VFat, BiosParameterBlock};
 use mbr::{MasterBootRecord, CHS, PartitionEntry};
 use traits::*;
 
-macro check_size($T:ty, $size:expr) {
-    assert_eq!(::std::mem::size_of::<$T>(), $size,
-        "'{}' does not have the expected size of {}", stringify!($T), $size);
+macro check_size($T: ty, $size: expr) {
+    assert_eq!(
+        ::std::mem::size_of::<$T>(),
+        $size,
+        "'{}' does not have the expected size of {}",
+        stringify!($T),
+        $size
+    );
 }
 
 macro expect_variant($e:expr, $variant:pat $(if $($cond:tt)*)*) {
@@ -346,6 +351,6 @@ fn test_mock4_files_recursive() {
 
 #[test]
 fn shared_fs_is_sync_send_static() {
-    fn f<T: Sync + Send + 'static>() {  }
+    fn f<T: Sync + Send + 'static>() {}
     f::<Shared<VFat>>();
 }
diff --git a/fat32/src/traits/dummy.rs b/fat32/src/traits/dummy.rs
index 38d7f34..cf16ae5 100644
--- a/fat32/src/traits/dummy.rs
+++ b/fat32/src/traits/dummy.rs
@@ -64,6 +64,9 @@ impl Metadata for Dummy {
     type Timestamp = Dummy;
     fn read_only(&self) -> bool { panic!("Dummy") }
     fn hidden(&self) -> bool { panic!("Dummy") }
+    fn system(&self) -> bool { panic!("Dummy") }
+    fn volume_id(&self) -> bool { panic!("Dummy") }
+    fn archive(&self) -> bool { panic!("Dummy") }
     fn created(&self) -> Self::Timestamp { panic!("Dummy") }
     fn accessed(&self) -> Self::Timestamp { panic!("Dummy") }
     fn modified(&self) -> Self::Timestamp { panic!("Dummy") }
diff --git a/fat32/src/traits/fs.rs b/fat32/src/traits/fs.rs
index 21f1c52..34684fb 100644
--- a/fat32/src/traits/fs.rs
+++ b/fat32/src/traits/fs.rs
@@ -1,5 +1,5 @@
 use std::io;
-use std::path::Path;
+use std::path::{Path, PathBuf};
 
 use traits::Metadata;
 
@@ -184,4 +184,6 @@ pub trait FileSystem: Sized {
     ///
     /// All other error values are implementation defined.
     fn remove<P: AsRef<Path>>(self, path: P, children: bool) -> io::Result<()>;
+
+    fn canonicalize<P :AsRef<Path>>(self, path: P) -> io::Result<PathBuf>;
 }
diff --git a/fat32/src/traits/metadata.rs b/fat32/src/traits/metadata.rs
index 524abe4..155a5b5 100644
--- a/fat32/src/traits/metadata.rs
+++ b/fat32/src/traits/metadata.rs
@@ -34,6 +34,10 @@ pub trait Metadata: Sized {
     /// Whether the entry should be "hidden" from directory traversals.
     fn hidden(&self) -> bool;
 
+    fn system(&self) -> bool;
+    fn volume_id(&self) -> bool;
+    fn archive(&self) -> bool;
+
     /// The timestamp when the entry was created.
     fn created(&self) -> Self::Timestamp;
 
diff --git a/fat32/src/vfat/cache.rs b/fat32/src/vfat/cache.rs
index ea952fb..89a468c 100644
--- a/fat32/src/vfat/cache.rs
+++ b/fat32/src/vfat/cache.rs
@@ -1,4 +1,5 @@
-use std::{io, fmt};
+use std::{fmt, io};
+use std::io::Read;
 use std::collections::HashMap;
 
 use traits::BlockDevice;
@@ -6,20 +7,20 @@ use traits::BlockDevice;
 #[derive(Debug)]
 struct CacheEntry {
     data: Vec<u8>,
-    dirty: bool
+    dirty: bool,
 }
 
 pub struct Partition {
     /// The physical sector where the partition begins.
     pub start: u64,
     /// The size, in bytes, of a logical sector in the partition.
-    pub sector_size: u64
+    pub sector_size: u64,
 }
 
 pub struct CachedDevice {
     device: Box<BlockDevice>,
     cache: HashMap<u64, CacheEntry>,
-    partition: Partition
+    partition: Partition,
 }
 
 impl CachedDevice {
@@ -43,14 +44,15 @@ impl CachedDevice {
     ///
     /// Panics if the partition's sector size is < the device's sector size.
     pub fn new<T>(device: T, partition: Partition) -> CachedDevice
-        where T: BlockDevice + 'static
+    where
+        T: BlockDevice + 'static,
     {
         assert!(partition.sector_size >= device.sector_size());
 
         CachedDevice {
             device: Box::new(device),
             cache: HashMap::new(),
-            partition: partition
+            partition: partition,
         }
     }
 
@@ -81,7 +83,10 @@ impl CachedDevice {
     ///
     /// Returns an error if there is an error reading the sector from the disk.
     pub fn get_mut(&mut self, sector: u64) -> io::Result<&mut [u8]> {
-        unimplemented!("CachedDevice::get_mut()")
+        self.get(sector)?;
+        let entry = self.cache.get_mut(&sector).unwrap();
+        entry.dirty = true;
+        Ok(entry.data.as_mut_slice())
     }
 
     /// Returns a reference to the cached sector `sector`. If the sector is not
@@ -91,18 +96,55 @@ impl CachedDevice {
     ///
     /// Returns an error if there is an error reading the sector from the disk.
     pub fn get(&mut self, sector: u64) -> io::Result<&[u8]> {
-        unimplemented!("CachedDevice::get()")
+        if !self.cache.contains_key(&sector) {
+            let (physical_sector, physical_sector_num) = self.virtual_to_physical(sector);
+            let physical_sector_size = self.device.sector_size();
+            let logical_sector_size = (physical_sector_size * physical_sector_num) as usize;
+            let mut new_vec = Vec::with_capacity(logical_sector_size);
+            new_vec.resize(logical_sector_size, 0);
+            for i in 0..physical_sector_num {
+                self.device.read_sector(
+                    physical_sector + i,
+                    &mut new_vec[(i * physical_sector_size) as usize..],
+                )?;
+            }
+            self.cache.insert(sector, CacheEntry {
+                data: new_vec,
+                dirty: false
+            });
+        }
+        Ok(&self.cache[&sector].data[..])
     }
 }
 
 // FIXME: Implement `BlockDevice` for `CacheDevice`. The `read_sector` and
 // `write_sector` methods should only read/write from/to cached sectors.
+impl BlockDevice for CachedDevice {
+    fn sector_size(&self) -> u64 {
+        self.partition.sector_size
+    }
+
+    fn read_sector(&mut self, n: u64, buf: &mut [u8]) -> io::Result<usize> {
+        if self.cache.contains_key(&n) {
+            let cached_entry = &self.cache[&n];
+            io::Cursor::new(&cached_entry.data).read(buf)
+        } else {
+            Err(io::Error::new(io::ErrorKind::Interrupted, "data not cached yet"))
+        }
+    }
+
+    fn write_sector(&mut self, n: u64, buf: &[u8]) -> io::Result<usize> {
+        unimplemented!();
+    }
+}
 
 impl fmt::Debug for CachedDevice {
     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+        let mut keys: Vec<&u64> = self.cache.keys().collect();
+        keys.sort();
         f.debug_struct("CachedDevice")
             .field("device", &"<block device>")
-            .field("cache", &self.cache)
+            .field("cached sectors", &keys)
             .finish()
     }
 }
diff --git a/fat32/src/vfat/cluster.rs b/fat32/src/vfat/cluster.rs
index f6d686f..742842f 100644
--- a/fat32/src/vfat/cluster.rs
+++ b/fat32/src/vfat/cluster.rs
@@ -10,3 +10,13 @@ impl From<u32> for Cluster {
 }
 
 // TODO: Implement any useful helper methods on `Cluster`.
+impl Cluster {
+    pub(super) fn cluster_num(&self) -> u32 {
+        self.0
+    }
+
+    pub(super) fn cluster_index(&self) -> u32 {
+        // Cluster start from 2
+        self.0 - 2
+    }
+}
diff --git a/fat32/src/vfat/dir.rs b/fat32/src/vfat/dir.rs
index 9ef83c1..7fcfa74 100644
--- a/fat32/src/vfat/dir.rs
+++ b/fat32/src/vfat/dir.rs
@@ -5,30 +5,52 @@ use std::io;
 
 use traits;
 use util::VecExt;
-use vfat::{VFat, Shared, File, Cluster, Entry};
-use vfat::{Metadata, Attributes, Timestamp, Time, Date};
+use vfat::{Cluster, Entry, File, Shared, VFat};
+use vfat::{Attributes, Date, Metadata, Time, Timestamp};
+use std::fmt;
+use std::str;
 
-#[derive(Debug)]
 pub struct Dir {
     // FIXME: Fill me in.
+    cluster: Cluster,
+    fs: Shared<VFat>,
+    short_name: String,
+    long_name: String,
+    pub(super) metadata: Metadata,
 }
 
-#[repr(C, packed)]
-#[derive(Copy, Clone)]
+#[repr(C, align(32))]
+#[derive(Debug, Copy, Clone)]
 pub struct VFatRegularDirEntry {
     // FIXME: Fill me in.
+    short_file_name: [u8; 8],
+    short_file_extension: [u8; 3],
+    metadata: Metadata,
+    file_size: u32,
 }
 
 #[repr(C, packed)]
-#[derive(Copy, Clone)]
+#[derive(Debug, Copy, Clone)]
 pub struct VFatLfnDirEntry {
     // FIXME: Fill me in.
+    sequence_number: u8,
+    name_characters: [u16; 5],
+    attributes: Attributes,
+    type_: u8,
+    checksum_of_file_name: u8,
+    name_characters_2: [u16; 6],
+    always_zero: u16,
+    name_characters_3: [u16; 2],
 }
 
 #[repr(C, packed)]
 #[derive(Copy, Clone)]
 pub struct VFatUnknownDirEntry {
     // FIXME: Fill me in.
+    status: u8,
+    __r1: [u8; 10],
+    attributes: Attributes,
+    __r2: [u8; 20],
 }
 
 pub union VFatDirEntry {
@@ -49,8 +71,174 @@ impl Dir {
     /// If `name` contains invalid UTF-8 characters, an error of `InvalidInput`
     /// is returned.
     pub fn find<P: AsRef<OsStr>>(&self, name: P) -> io::Result<Entry> {
-        unimplemented!("Dir::find()")
+        use traits::{Dir, Entry};
+        let lowercase_name = match name.as_ref().to_str() {
+            Some(name_str) => name_str.to_lowercase(),
+            None => {
+                return Err(io::Error::new(
+                    io::ErrorKind::InvalidInput,
+                    "name is not valid UTF-8 string",
+                ))
+            }
+        };
+        for entry in self.entries()? {
+            if lowercase_name == entry.name().to_lowercase() {
+                return Ok(entry);
+            }
+        }
+        Err(io::Error::new(io::ErrorKind::NotFound, "entry not found"))
+    }
+
+    pub fn name(&self) -> &str {
+        if self.long_name.len() > 0 {
+            self.long_name.as_str()
+        } else {
+            self.short_name.as_str()
+        }
+    }
+
+    pub(super) fn new_root(fs: &Shared<VFat>) -> Dir {
+        let cluster = fs.borrow().root_dir_cluster;
+        Dir {
+            cluster: cluster,
+            fs: fs.clone(),
+            short_name: String::new(),
+            long_name: String::new(),
+            metadata: Metadata::default(),
+        }
     }
 }
 
 // FIXME: Implement `trait::Dir` for `Dir`.
+pub struct EntryIterator {
+    data: Vec<u8>,
+    current_index: usize,
+    fs: Shared<VFat>,
+    bytes_per_cluster: u32,
+}
+
+impl Iterator for EntryIterator {
+    type Item = Entry;
+
+    fn next(&mut self) -> Option<Self::Item> {
+        let entries: *const VFatDirEntry = self.data.as_ptr() as *const VFatDirEntry;
+        let mut long_file_name = [0u16; 300];
+        loop {
+            let current_entry: &VFatDirEntry = unsafe {
+                entries
+                    .offset(self.current_index as isize)
+                    .as_ref()
+                    .unwrap()
+            };
+            let unknown_entry = unsafe { current_entry.unknown };
+            if unknown_entry.status == 0x00 {
+                // End of FAT
+                return None;
+            } else if unknown_entry.status == 0xE5 {
+                // Deleted entry
+                self.current_index += 1;
+                continue;
+            }
+
+            // Normal entry,
+            self.current_index += 1;
+            if unknown_entry.attributes.lfn() {
+                let lfn_entry = unsafe { current_entry.long_filename };
+                let lfn_sequence_num = (lfn_entry.sequence_number & 0x1F) as usize - 1;
+
+                long_file_name[lfn_sequence_num * 13..lfn_sequence_num * 13 + 5]
+                    .copy_from_slice(&lfn_entry.name_characters);
+                long_file_name[lfn_sequence_num * 13 + 5..lfn_sequence_num * 13 + 11]
+                    .copy_from_slice(&lfn_entry.name_characters_2);
+                long_file_name[lfn_sequence_num * 13 + 11..lfn_sequence_num * 13 + 13]
+                    .copy_from_slice(&lfn_entry.name_characters_3);
+            } else {
+                let regular_entry = unsafe { current_entry.regular };
+                let mut short_file_name = regular_entry.short_file_name.clone();
+                if short_file_name[0] == 0x05 {
+                    // 0x05 is used for real 0xE5 as first byte
+                    short_file_name[0] = 0xE5;
+                }
+                let name = str::from_utf8(&short_file_name).unwrap().trim_right();
+                let ext = str::from_utf8(&regular_entry.short_file_extension)
+                    .unwrap()
+                    .trim_right();
+                let mut short_name = String::from(name);
+                if ext.len() > 0 {
+                    short_name.push_str(".");
+                    short_name.push_str(ext);
+                }
+                let mut nul_byte_index = None;
+                for (i, byte) in long_file_name.iter().enumerate() {
+                    if *byte == 0 {
+                        nul_byte_index = Some(i);
+                        break;
+                    }
+                }
+                let long_name = String::from_utf16(if let Some(len) = nul_byte_index {
+                    &long_file_name[0..len]
+                } else {
+                    &long_file_name
+                }).unwrap();
+                if regular_entry.metadata.attributes.directory() {
+                    return Some(Entry::Dir(Dir {
+                        cluster: Cluster::from(regular_entry.metadata.first_cluster()),
+                        fs: self.fs.clone(),
+                        short_name,
+                        long_name,
+                        metadata: regular_entry.metadata,
+                    }));
+                } else {
+                    return Some(Entry::File(File {
+                        cluster: Cluster::from(regular_entry.metadata.first_cluster()),
+                        fs: self.fs.clone(),
+                        short_name,
+                        long_name,
+                        metadata: regular_entry.metadata,
+                        file_size: regular_entry.file_size,
+                        current_offset: 0,
+                        current_cluster: Some(Cluster::from(
+                            regular_entry.metadata.first_cluster(),
+                        )),
+                        bytes_per_cluster: self.bytes_per_cluster,
+                    }));
+                }
+            }
+        }
+    }
+}
+
+impl traits::Dir for Dir {
+    type Entry = Entry;
+
+    /// An type that is an iterator over the entries in this directory.
+    type Iter = EntryIterator;
+
+    /// Returns an interator over the entries in this directory.
+    fn entries(&self) -> io::Result<Self::Iter> {
+        let mut data = Vec::new();
+        let bytes_per_cluster = {
+            let mut fs_borrow = self.fs.borrow_mut();
+            fs_borrow.read_chain(self.cluster, &mut data)?;
+            fs_borrow.bytes_per_sector as u32 * fs_borrow.sectors_per_cluster as u32
+        };
+
+        Ok(EntryIterator {
+            data: data,
+            current_index: 0,
+            fs: self.fs.clone(),
+            bytes_per_cluster,
+        })
+    }
+}
+
+impl fmt::Debug for Dir {
+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+        f.debug_struct("Dir")
+            .field("short_name", &self.short_name)
+            .field("long_name", &self.long_name)
+            .field("cluster", &self.cluster)
+            .field("metadata", &self.metadata)
+            .finish()
+    }
+}
diff --git a/fat32/src/vfat/ebpb.rs b/fat32/src/vfat/ebpb.rs
index 2878c6f..660097a 100644
--- a/fat32/src/vfat/ebpb.rs
+++ b/fat32/src/vfat/ebpb.rs
@@ -2,10 +2,42 @@ use std::fmt;
 
 use traits::BlockDevice;
 use vfat::Error;
+use util::SliceExt;
+use std::io;
 
 #[repr(C, packed)]
+#[derive(Copy, Clone)]
 pub struct BiosParameterBlock {
     // FIXME: Fill me in.
+    jump_instruction: [u8; 3],
+    oem_identifier: [u8; 8],
+    pub(super) bytes_per_sector: u16,
+    pub(super) sectors_per_cluster: u8,
+    pub(super) reserved_sectors: u16,
+    pub(super) number_of_fats: u8,
+    max_directory_entries: u16, // always 0 in FAT32
+    total_logical_sectors: u16, // use _2 in FAT32
+    media_descriptor: u8,
+    sectors_per_fat: u16, // use _2 in FAT32
+    sectors_per_track: u16,
+    number_of_heads: u16,
+    hidden_sectors: u32,
+    total_logical_sectors_2: u32,
+    sectors_per_fat_2: u32,
+    flags: u16,
+    version: u16,
+    pub(super) root_directory_cluster: u32,
+    location_of_fs_information_sector: u16,
+    location_of_backup_sector: u16,
+    __r2: [u8; 12],
+    physical_drive_number: u8,
+    __r3: u8,
+    signature: u8, // 0x28 or 0x29
+    volume_serial_number: u32,
+    volume_label: [u8; 11],
+    fs_type: [u8; 8],
+    __r4: [u8; 420],
+    magic: u16,
 }
 
 impl BiosParameterBlock {
@@ -15,16 +47,39 @@ impl BiosParameterBlock {
     /// # Errors
     ///
     /// If the EBPB signature is invalid, returns an error of `BadSignature`.
-    pub fn from<T: BlockDevice>(
-        mut device: T,
-        sector: u64
-    ) -> Result<BiosParameterBlock, Error> {
-        unimplemented!("BiosParameterBlock::from()")
+    pub fn from<T: BlockDevice>(mut device: T, sector: u64) -> Result<BiosParameterBlock, Error> {
+        let mut buf = [0u8; 512];
+        match device.read_sector(sector, &mut buf) {
+            Ok(size) => {
+                if size != 512 {
+                    Err(Error::Io(io::Error::new(
+                        io::ErrorKind::UnexpectedEof,
+                        "unable to read 512 bytes of EBPB",
+                    )))
+                } else {
+                    let result: &BiosParameterBlock = unsafe { &buf.cast()[0] };
+                    if result.magic == 0xaa55 {
+                        Ok(result.clone())
+                    } else {
+                        Err(Error::BadSignature)
+                    }
+                }
+            }
+            Err(err) => Err(Error::Io(err)),
+        }
+    }
+
+    pub(super) fn sectors_per_fat(&self) -> u32 {
+        if self.sectors_per_fat > 0 {
+            self.sectors_per_fat as u32
+        } else {
+            self.sectors_per_fat_2
+        }
     }
 }
 
 impl fmt::Debug for BiosParameterBlock {
     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
-        unimplemented!("BiosParameterBlock::debug()")
+        f.debug_struct("BiosParameterBlock").finish()
     }
 }
diff --git a/fat32/src/vfat/entry.rs b/fat32/src/vfat/entry.rs
index cc1604f..542dc6f 100644
--- a/fat32/src/vfat/entry.rs
+++ b/fat32/src/vfat/entry.rs
@@ -1,13 +1,60 @@
 use traits;
-use vfat::{File, Dir, Metadata, Cluster};
+use vfat::{Cluster, Dir, File, Metadata};
 
 // TODO: You may need to change this definition.
 #[derive(Debug)]
 pub enum Entry {
     File(File),
-    Dir(Dir)
+    Dir(Dir),
 }
 
 // TODO: Implement any useful helper methods on `Entry`.
 
 // FIXME: Implement `traits::Entry` for `Entry`.
+impl traits::Entry for Entry {
+    type File = File;
+    type Dir = Dir;
+    type Metadata = Metadata;
+
+    fn name(&self) -> &str {
+        match self {
+            &Entry::File(ref file) => file.name(),
+            &Entry::Dir(ref dir) => dir.name(),
+        }
+    }
+
+    fn metadata(&self) -> &Self::Metadata {
+        match self {
+            &Entry::File(ref file) => &file.metadata,
+            &Entry::Dir(ref dir) => &dir.metadata,
+        }
+    }
+
+    fn as_file(&self) -> Option<&Self::File> {
+        match self {
+            &Entry::File(ref file) => Some(file),
+            _ => None
+        }
+    }
+
+    fn as_dir(&self) -> Option<&Self::Dir> {
+        match self {
+            &Entry::Dir(ref dir) => Some(dir),
+            _ => None
+        }
+    }
+
+    fn into_file(self) -> Option<Self::File> {
+        match self {
+            Entry::File(file) => Some(file),
+            _ => None
+        }
+    }
+
+    fn into_dir(self) -> Option<Self::Dir> {
+        match self {
+            Entry::Dir(dir) => Some(dir),
+            _ => None
+        }
+    }
+}
diff --git a/fat32/src/vfat/fat.rs b/fat32/src/vfat/fat.rs
index c89e0ef..1b31f84 100644
--- a/fat32/src/vfat/fat.rs
+++ b/fat32/src/vfat/fat.rs
@@ -20,12 +20,33 @@ pub enum Status {
 }
 
 #[repr(C, packed)]
-pub struct FatEntry(pub u32);
+pub struct FatEntry(u32);
 
 impl FatEntry {
     /// Returns the `Status` of the FAT entry `self`.
-    pub fn status(&self) -> Status {
-        unimplemented!("FatEntry::status()")
+    pub(super) fn status(&self) -> Status {
+        let bits = self.0 & (0x0FFFFFFFu32);
+        match bits {
+            0x00000000 => {
+                Free
+            }
+            0x00000001 => {
+                Reserved
+            }
+            0x00000002 ... 0x0FFFFFEF => {
+                Data(Cluster::from(self.0))
+            }
+            0x0FFFFFF0 ... 0x0FFFFFF6 => {
+                Reserved
+            }
+            0x0FFFFFF7 => {
+                Bad
+            }
+            0x0FFFFFF8 ... 0x0FFFFFFF => {
+                Eoc(self.0)
+            }
+            _ => unreachable!()
+        }
     }
 }
 
diff --git a/fat32/src/vfat/file.rs b/fat32/src/vfat/file.rs
index fed2007..3fc0b3f 100644
--- a/fat32/src/vfat/file.rs
+++ b/fat32/src/vfat/file.rs
@@ -1,15 +1,77 @@
-use std::cmp::{min, max};
+use std::cmp::{max, min};
 use std::io::{self, SeekFrom};
 
 use traits;
-use vfat::{VFat, Shared, Cluster, Metadata};
+use vfat::{Cluster, Metadata, Shared, Status, VFat};
+use std::fmt;
 
-#[derive(Debug)]
 pub struct File {
     // FIXME: Fill me in.
+    pub(super) cluster: Cluster,
+    pub(super) fs: Shared<VFat>,
+    pub(super) short_name: String,
+    pub(super) long_name: String,
+    pub(super) metadata: Metadata,
+    pub(super) file_size: u32,
+    pub(super) current_offset: u32,
+    pub(super) current_cluster: Option<Cluster>,
+    pub(super) bytes_per_cluster: u32,
 }
 
 // FIXME: Implement `traits::File` (and its supertraits) for `File`.
+impl traits::File for File {
+    fn sync(&mut self) -> io::Result<()> {
+        unimplemented!()
+    }
+
+    fn size(&self) -> u64 {
+        self.file_size as u64
+    }
+}
+
+impl io::Read for File {
+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
+        let read_size = min(buf.len(), (self.file_size - self.current_offset) as usize);
+        let mut current_offset_in_cluster = (self.current_offset % self.bytes_per_cluster) as usize;
+        let mut fs = self.fs.borrow_mut();
+        let mut rest_size = read_size;
+        let mut current_cluster = self.current_cluster;
+        let mut buffer_offset = 0;
+        while rest_size > 0 {
+            let newly_read_size = fs.read_cluster(
+                current_cluster.unwrap(),
+                current_offset_in_cluster,
+                &mut buf[buffer_offset..read_size],
+            )?;
+            if newly_read_size == self.bytes_per_cluster as usize - current_offset_in_cluster {
+                // read all content of current cluster
+                match fs.fat_entry(current_cluster.unwrap())?.status() {
+                    Status::Eoc(_) => current_cluster = None,
+                    Status::Data(next_cluster) => {
+                        current_cluster = Some(next_cluster);
+                    }
+                    _ => unimplemented!(),
+                }
+            }
+            buffer_offset += newly_read_size;
+            rest_size -= newly_read_size;
+            current_offset_in_cluster = 0;
+        }
+        self.current_offset += read_size as u32;
+        self.current_cluster = current_cluster;
+        Ok(read_size)
+    }
+}
+
+impl io::Write for File {
+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
+        unimplemented!()
+    }
+
+    fn flush(&mut self) -> io::Result<()> {
+        unimplemented!()
+    }
+}
 
 impl io::Seek for File {
     /// Seek to offset `pos` in the file.
@@ -26,6 +88,52 @@ impl io::Seek for File {
     /// Seeking before the start of a file or beyond the end of the file results
     /// in an `InvalidInput` error.
     fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {
-        unimplemented!("File::seek()")
+        let new_offset = match pos {
+            SeekFrom::Start(start) => start as u32,
+            SeekFrom::Current(offset) => self.current_offset.wrapping_add(offset as u32),
+            SeekFrom::End(offset) => self.file_size.wrapping_add(offset as u32),
+        };
+        if new_offset >= self.file_size {
+            Err(io::Error::new(
+                io::ErrorKind::InvalidInput,
+                "invalid seek position",
+            ))
+        } else {
+            let mut current_cluster = self.cluster;
+            let mut fs = self.fs.borrow_mut();
+            for _ in 0..(new_offset / self.bytes_per_cluster) {
+                match fs.fat_entry(current_cluster)?.status() {
+                    Status::Data(next_cluster) => {
+                        current_cluster = next_cluster;
+                    }
+                    _ => unimplemented!(),
+                }
+            }
+            self.current_cluster = Some(current_cluster);
+            self.current_offset = new_offset;
+            Ok(self.current_offset as u64)
+        }
+    }
+}
+
+impl File {
+    pub fn name(&self) -> &str {
+        if self.long_name.len() > 0 {
+            self.long_name.as_str()
+        } else {
+            self.short_name.as_str()
+        }
+    }
+}
+
+impl fmt::Debug for File {
+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+        f.debug_struct("File")
+            .field("short_name", &self.short_name)
+            .field("long_name", &self.long_name)
+            .field("cluster", &self.cluster)
+            .field("metadata", &self.metadata)
+            .field("file_size", &self.file_size)
+            .finish()
     }
 }
diff --git a/fat32/src/vfat/metadata.rs b/fat32/src/vfat/metadata.rs
index 1822cc5..8f10d03 100644
--- a/fat32/src/vfat/metadata.rs
+++ b/fat32/src/vfat/metadata.rs
@@ -18,20 +18,171 @@ pub struct Time(u16);
 pub struct Attributes(u8);
 
 /// A structure containing a date and time.
-#[derive(Default, Copy, Clone, Debug, PartialEq, Eq)]
+#[derive(Default, Copy, Clone, PartialEq, Eq)]
 pub struct Timestamp {
-    pub date: Date,
-    pub time: Time
+    pub(super) date: Date,
+    pub(super) time: Time,
 }
 
 /// Metadata for a directory entry.
-#[derive(Default, Debug, Clone)]
+#[repr(C, packed)]
+#[derive(Default, Copy, Clone)]
 pub struct Metadata {
     // FIXME: Fill me in.
+    pub(super) attributes: Attributes,
+    __r1: u8,
+    creation_time_tenths_seconds: u8,
+    creation_time: Time,
+    creation_date: Date,
+    access_date: Date,
+    high_two_bytes_first_cluster: u16,
+    last_modified_time: Time,
+    last_modified_date: Date,
+    low_two_bytes_first_cluster: u16,
 }
 
 // FIXME: Implement `traits::Timestamp` for `Timestamp`.
+impl traits::Timestamp for Timestamp {
+    fn year(&self) -> usize {
+        ((self.date.0 >> 9) & 0x7F) as usize + 1980
+    }
+
+    /// The calendar month, starting at 1 for January. Always in range [1, 12].
+    ///
+    /// January is 1, Feburary is 2, ..., December is 12.
+    fn month(&self) -> u8 {
+        ((self.date.0 >> 5) & 0xF) as u8
+    }
+
+    /// The calendar day, starting at 1. Always in range [1, 31].
+    fn day(&self) -> u8 {
+        (self.date.0 & 0x1F) as u8
+    }
+
+    /// The 24-hour hour. Always in range [0, 24).
+    fn hour(&self) -> u8 {
+        ((self.time.0 >> 11) & 0x1F) as u8
+    }
+
+    /// The minute. Always in range [0, 60).
+    fn minute(&self) -> u8 {
+        ((self.time.0 >> 5) & 0x3F) as u8
+    }
+
+    /// The second. Always in range [0, 60).
+    fn second(&self) -> u8 {
+        (self.time.0 & 0x1F) as u8 * 2
+    }
+}
+
+impl Attributes {
+    fn read_only(&self) -> bool {
+        (self.0 & 0x01) != 0
+    }
+
+    fn hidden(&self) -> bool {
+        (self.0 & 0x02) != 0
+    }
+
+    fn system(&self) -> bool {
+        (self.0 & 0x04) != 0
+    }
+
+    fn volume_id(&self) -> bool {
+        (self.0 & 0x08) != 0
+    }
+
+    pub(super) fn directory(&self) -> bool {
+        (self.0 & 0x10) != 0
+    }
+
+    fn archive(&self) -> bool {
+        (self.0 & 0x20) != 0
+    }
+
+    pub(super) fn lfn(&self) -> bool {
+        self.0 == 0x0F
+    }
+}
 
 // FIXME: Implement `traits::Metadata` for `Metadata`.
+impl traits::Metadata for Metadata {
+    type Timestamp = Timestamp;
+
+    fn read_only(&self) -> bool {
+        self.attributes.read_only()
+    }
+
+    fn hidden(&self) -> bool {
+        self.attributes.hidden()
+    }
+
+    fn system(&self) -> bool {
+        self.attributes.system()
+    }
+
+    fn volume_id(&self) -> bool {
+        self.attributes.volume_id()
+    }
+
+    fn archive(&self) -> bool {
+        self.attributes.archive()
+    }
+
+    fn created(&self) -> Self::Timestamp {
+        Timestamp {
+            // TODO: deal with tenth second?
+            time: self.creation_time,
+            date: self.creation_date,
+        }
+    }
+
+    fn accessed(&self) -> Self::Timestamp {
+        Timestamp {
+            time: Time(0),
+            date: self.access_date,
+        }
+    }
+
+    fn modified(&self) -> Self::Timestamp {
+        Timestamp {
+            time: self.last_modified_time,
+            date: self.last_modified_date,
+        }
+    }
+}
 
 // FIXME: Implement `fmt::Display` (to your liking) for `Metadata`.
+impl fmt::Debug for Metadata {
+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+        use traits::Metadata;
+        f.debug_struct("Metadata")
+            .field("read_only", &self.read_only())
+            .field("hidden", &self.hidden())
+            .field("created", &self.created())
+            .field("accessed", &self.accessed())
+            .field("modified", &self.modified())
+            .finish()
+    }
+}
+
+impl fmt::Debug for Timestamp {
+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+        use traits::Timestamp;
+        f.write_fmt(format_args!(
+            "{:04}-{:02}-{:02} {:02}:{:02}:{:02}",
+            self.year(),
+            self.month(),
+            self.day(),
+            self.hour(),
+            self.minute(),
+            self.second()
+        ))
+    }
+}
+
+impl Metadata {
+    pub(super) fn first_cluster(&self) -> u32 {
+        ((self.high_two_bytes_first_cluster as u32) << 16) | self.low_two_bytes_first_cluster as u32
+    }
+}
\ No newline at end of file
diff --git a/fat32/src/vfat/mod.rs b/fat32/src/vfat/mod.rs
index 82527ae..d7951be 100644
--- a/fat32/src/vfat/mod.rs
+++ b/fat32/src/vfat/mod.rs
@@ -22,3 +22,6 @@ pub use self::shared::Shared;
 pub(crate) use self::cache::{CachedDevice, Partition};
 pub(crate) use self::fat::{Status, FatEntry};
 pub(crate) use self::cluster::Cluster;
+
+#[cfg(test)]
+mod tests;
diff --git a/fat32/src/vfat/tests.rs b/fat32/src/vfat/tests.rs
index e69de29..ba13ef6 100644
--- a/fat32/src/vfat/tests.rs
+++ b/fat32/src/vfat/tests.rs
@@ -0,0 +1,78 @@
+use std::fs;
+use std::io::{Read, Seek, SeekFrom};
+use std::mem::transmute;
+use traits::FileSystem;
+use traits::Entry;
+use traits::Dir;
+use traits::File;
+use util::SliceExt;
+use util::VecExt;
+
+#[test]
+fn test_raspbian_img_vfat() {
+    let file =
+        fs::File::open("/Volumes/Data/raspbian/2017-11-29-raspbian-stretch-lite.img").unwrap();
+    let shared_vfat = ::vfat::VFat::from(file).unwrap();
+    {
+        let mut vfat = shared_vfat.borrow_mut();
+        let root_cluster = vfat.root_dir_cluster;
+        let mut buffer = Vec::new();
+        vfat.read_chain(root_cluster, &mut buffer).unwrap();
+        println!("{:?}", *vfat);
+    }
+
+    let root = shared_vfat.open("/").unwrap();
+    println!("{:?}", root);
+    let root_dir = root.as_dir().unwrap();
+    for entry in root_dir.entries().unwrap() {
+        println!("{:?}", entry);
+        if entry.is_dir() {
+            for sub_entry in entry.as_dir().unwrap().entries().unwrap() {
+                println!("{:?}", sub_entry);
+            }
+        }
+    }
+    let overlays = shared_vfat.open("/overlays/ads1015.dtbo").unwrap();
+    println!("{:?}", overlays);
+}
+
+#[test]
+fn test_raspbian_img_mbr() {
+    let file =
+        fs::File::open("/Volumes/Data/raspbian/2017-11-29-raspbian-stretch-lite.img").unwrap();
+    let mbr = ::mbr::MasterBootRecord::from(file);
+    println!("{:?}", mbr);
+}
+
+#[test]
+fn test_raspbian_img_ebpb() {
+    let mut file =
+        fs::File::open("/Volumes/Data/raspbian/2017-11-29-raspbian-stretch-lite.img").unwrap();
+    let mbr = ::mbr::MasterBootRecord::from(&mut file).unwrap();
+    let fat_start_sector = mbr.first_vfat_partition_lba().unwrap() as u64;
+    let ebpb = ::vfat::ebpb::BiosParameterBlock::from(&mut file, fat_start_sector).unwrap();
+    println!("{:?}", ebpb);
+}
+
+#[test]
+fn test_raspbian_img_config_txt() {
+    let mut file =
+        fs::File::open("/Volumes/Data/raspbian/2017-11-29-raspbian-stretch-lite.img").unwrap();
+    let mut shared_vfat = ::vfat::VFat::from(file).unwrap();
+    let mut config_txt = shared_vfat
+        .open("/config.txt")
+        .unwrap()
+        .into_file()
+        .unwrap();
+    let mut contents = String::new();
+    config_txt.read_to_string(&mut contents).unwrap();
+    config_txt.seek(SeekFrom::Start(0)).unwrap();
+    for i in 1..contents.len() - 2 {
+        let mut contents2 = String::new();
+        config_txt.seek(SeekFrom::Start(0)).unwrap();
+        config_txt.seek(SeekFrom::Current(i as i64)).unwrap();
+        config_txt.read_to_string(&mut contents2).unwrap();
+        println!("{:?}", contents2);
+        assert_eq!(&contents[i..], &contents2[..]);
+    }
+}
diff --git a/fat32/src/vfat/vfat.rs b/fat32/src/vfat/vfat.rs
index 7059b43..447111d 100644
--- a/fat32/src/vfat/vfat.rs
+++ b/fat32/src/vfat/vfat.rs
@@ -1,30 +1,56 @@
 use std::io;
-use std::path::Path;
+use std::path::{Path, PathBuf};
 use std::mem::size_of;
 use std::cmp::min;
 
 use util::SliceExt;
 use mbr::MasterBootRecord;
-use vfat::{Shared, Cluster, File, Dir, Entry, FatEntry, Error, Status};
+use vfat::{Cluster, Dir, Entry, Error, FatEntry, File, Shared, Status};
 use vfat::{BiosParameterBlock, CachedDevice, Partition};
-use traits::{FileSystem, BlockDevice};
+use traits::{BlockDevice, FileSystem};
+use std::path::Component;
 
 #[derive(Debug)]
 pub struct VFat {
     device: CachedDevice,
-    bytes_per_sector: u16,
-    sectors_per_cluster: u8,
+    pub(super) bytes_per_sector: u16,
+    pub(super) sectors_per_cluster: u8,
     sectors_per_fat: u32,
     fat_start_sector: u64,
     data_start_sector: u64,
-    root_dir_cluster: Cluster,
+    pub(super) root_dir_cluster: Cluster,
 }
 
 impl VFat {
     pub fn from<T>(mut device: T) -> Result<Shared<VFat>, Error>
-        where T: BlockDevice + 'static
+    where
+        T: BlockDevice + 'static,
     {
-        unimplemented!("VFat::from()")
+        let mbr = MasterBootRecord::from(&mut device)?;
+        let fat_start_sector_option = mbr.first_vfat_partition_lba();
+        let fat_start_sector = match fat_start_sector_option {
+            Some(sector) => sector as u64,
+            None => return Err(Error::NotFound),
+        };
+        let ebpb = BiosParameterBlock::from(&mut device, fat_start_sector)?;
+        let sectors_per_fat = ebpb.sectors_per_fat();
+        let cached_device = CachedDevice::new(
+            device,
+            Partition {
+                start: fat_start_sector,
+                sector_size: ebpb.bytes_per_sector as u64,
+            },
+        );
+        Ok(Shared::new(VFat {
+            device: cached_device,
+            bytes_per_sector: ebpb.bytes_per_sector,
+            sectors_per_cluster: ebpb.sectors_per_cluster,
+            sectors_per_fat: sectors_per_fat,
+            fat_start_sector: fat_start_sector + ebpb.reserved_sectors as u64,
+            data_start_sector: fat_start_sector + ebpb.reserved_sectors as u64
+                + (sectors_per_fat * ebpb.number_of_fats as u32) as u64,
+            root_dir_cluster: Cluster::from(ebpb.root_directory_cluster),
+        }))
     }
 
     // TODO: The following methods may be useful here:
@@ -51,15 +77,139 @@ impl VFat {
     //    reference points directly into a cached sector.
     //
     //    fn fat_entry(&mut self, cluster: Cluster) -> io::Result<&FatEntry>;
+
+    pub(super) fn fat_entry(&mut self, cluster: Cluster) -> io::Result<&FatEntry> {
+        let cluster_num_sector: u64 = cluster.cluster_num() as u64 * size_of::<FatEntry>() as u64
+            / self.bytes_per_sector as u64;
+        let entry_offset: usize =
+            cluster.cluster_num() as usize * size_of::<FatEntry>() % self.bytes_per_sector as usize;
+        let content = self.device.get(self.fat_start_sector + cluster_num_sector)?;
+        let entries: &[FatEntry] = unsafe { content.cast() };
+        Ok(&entries[entry_offset / size_of::<FatEntry>()])
+    }
+
+    pub(super) fn read_cluster(
+        &mut self,
+        cluster: Cluster,
+        offset: usize,
+        buf: &mut [u8],
+    ) -> io::Result<usize> {
+        let sector_size = self.device.sector_size() as usize;
+        let size = min(
+            buf.len(),
+            self.bytes_per_sector as usize * self.sectors_per_cluster as usize - offset,
+        );
+        let mut current_sector = self.data_start_sector
+            + cluster.cluster_index() as u64 * self.sectors_per_cluster as u64
+            + offset as u64 / self.bytes_per_sector as u64;
+        let mut bytes_read = 0;
+        let mut offset_once = offset % self.bytes_per_sector as usize;
+        while bytes_read < size {
+            let content = self.device.get(current_sector)?;
+            let copy_size = min(size - bytes_read, sector_size - offset_once);
+            buf[bytes_read..bytes_read + copy_size]
+                .copy_from_slice(&content[offset_once..offset_once + copy_size]);
+            offset_once = 0;
+            bytes_read += copy_size;
+            current_sector += 1;
+        }
+
+        Ok(size)
+    }
+
+    pub(super) fn read_chain(&mut self, start: Cluster, buf: &mut Vec<u8>) -> io::Result<usize> {
+        let mut current_cluster = start;
+        let mut current_cluster_num = 0;
+        let bytes_per_cluster = self.bytes_per_sector as usize * self.sectors_per_cluster as usize;
+        loop {
+            current_cluster_num += 1;
+            buf.resize(bytes_per_cluster * current_cluster_num, 0);
+            self.read_cluster(
+                current_cluster,
+                0,
+                &mut buf[bytes_per_cluster * (current_cluster_num - 1)..],
+            )?;
+            match self.fat_entry(current_cluster)?.status() {
+                Status::Eoc(_) => {
+                    return Ok(bytes_per_cluster * current_cluster_num);
+                }
+                Status::Data(next_cluster) => {
+                    current_cluster = next_cluster;
+                }
+                _ => unimplemented!(),
+            }
+        }
+    }
+}
+
+impl Shared<VFat> {
+    fn get_entries<P: AsRef<Path>>(&self, path_ref: P) -> io::Result<Vec<Entry>> {
+        let path = path_ref.as_ref();
+        if !path.is_absolute() {
+            return Err(io::Error::new(io::ErrorKind::InvalidInput, "path must be absolute"))
+        }
+
+        let mut dir_entries = Vec::new();
+        for component in path.components() {
+            match component {
+                Component::RootDir => {
+                    dir_entries.truncate(0);
+                    dir_entries.push(Entry::Dir(Dir::new_root(self)))
+                }
+                Component::CurDir => {} // do nothing
+                Component::Normal(name) => {
+                    use traits::Entry;
+                    let new_entry = match dir_entries.last() {
+                        Some(current_entry) => match current_entry.as_dir() {
+                            Some(dir) => dir.find(name)?,
+                            None => {
+                                return Err(io::Error::new(
+                                    io::ErrorKind::NotFound,
+                                    "file not found",
+                                ))
+                            }
+                        },
+                        None => return Err(io::Error::from(io::ErrorKind::NotFound)),
+                    };
+                    dir_entries.push(new_entry);
+                }
+                Component::ParentDir => {
+                    if dir_entries.len() > 0 {
+                        dir_entries.pop();
+                    } else {
+                        return Err(io::Error::from(io::ErrorKind::NotFound));
+                    }
+                }
+                _ => unimplemented!(),
+            }
+        }
+        Ok(dir_entries)
+    }
 }
 
 impl<'a> FileSystem for &'a Shared<VFat> {
-    type File = ::traits::Dummy;
-    type Dir = ::traits::Dummy;
-    type Entry = ::traits::Dummy;
+    type File = File;
+    type Dir = Dir;
+    type Entry = Entry;
+
+
+    fn open<P: AsRef<Path>>(self, path_ref: P) -> io::Result<Self::Entry> {
+        let dir_entries = self.get_entries(path_ref)?;
+
+        match dir_entries.into_iter().last() {
+            Some(current_entry) => Ok(current_entry),
+            None => Err(io::Error::from(io::ErrorKind::NotFound)),
+        }
+    }
 
-    fn open<P: AsRef<Path>>(self, path: P) -> io::Result<Self::Entry> {
-        unimplemented!("FileSystem::open()")
+    fn canonicalize<P: AsRef<Path>>(self, path_ref: P) -> io::Result<PathBuf> {
+        let dir_entries = self.get_entries(path_ref)?;
+        let mut result = PathBuf::from("/");
+        for entry in dir_entries {
+            use traits::Entry;
+            result.push(entry.name());
+        }
+        Ok(result)
     }
 
     fn create_file<P: AsRef<Path>>(self, _path: P) -> io::Result<Self::File> {
@@ -67,13 +217,16 @@ impl<'a> FileSystem for &'a Shared<VFat> {
     }
 
     fn create_dir<P>(self, _path: P, _parents: bool) -> io::Result<Self::Dir>
-        where P: AsRef<Path>
+    where
+        P: AsRef<Path>,
     {
         unimplemented!("read only file system")
     }
 
     fn rename<P, Q>(self, _from: P, _to: Q) -> io::Result<()>
-        where P: AsRef<Path>, Q: AsRef<Path>
+    where
+        P: AsRef<Path>,
+        Q: AsRef<Path>,
     {
         unimplemented!("read only file system")
     }
diff --git a/questions/atag-cmdline b/questions/atag-cmdline
index e69de29..aa5607d 100644
--- a/questions/atag-cmdline
+++ b/questions/atag-cmdline
@@ -0,0 +1,2 @@
+Content:
+bcm2708_fb.fbwidth=656 bcm2708_fb.fbheight=416 bcm2708_fb.fbswap=1 dma.dmachans=0x7f35 bcm2709.boardrev=0xa02082 bcm2709.serial=0xe5da193c bcm2709.uart_clock=48000000 smsc95xx.macaddr=B8:27:EB:DA:19:3C vc_mem.mem_base=0x3ec00000 vc_mem.mem_size=0x40000000  console=ttyS0,115200 kgdboc=ttyS0,115200 console=tty1 root=/dev/mmcblk0p2 rootfstype=ext4 rootwait
diff --git a/questions/atag-mem b/questions/atag-mem
index e69de29..7086dea 100644
--- a/questions/atag-mem
+++ b/questions/atag-mem
@@ -0,0 +1,2 @@
+Memory: start=0, size=994050048
+994050048=948MiB
diff --git a/questions/enduser-unsafe b/questions/enduser-unsafe
index e69de29..c977762 100644
--- a/questions/enduser-unsafe
+++ b/questions/enduser-unsafe
@@ -0,0 +1 @@
+We can limit `unsafe' to only a small portion of code that we can easily check, leaving rest of the code safe Rust. It's hard to enforce the same constraint in C.
diff --git a/questions/lfn-identity b/questions/lfn-identity
index e69de29..9a44fbb 100644
--- a/questions/lfn-identity
+++ b/questions/lfn-identity
@@ -0,0 +1 @@
+The attribute field is shared among regular entry and lfn entry. But a latter one has 0x0F in this field, which is impossible for a former one.
diff --git a/questions/libc-align b/questions/libc-align
index e69de29..812b49e 100644
--- a/questions/libc-align
+++ b/questions/libc-align
@@ -0,0 +1 @@
+Because `malloc' returns a pointer that is aligned for any kind of type. It must return a pointer that is aligned to max alignment, which is 2*sizeof(int). 
diff --git a/questions/ll-alloc b/questions/ll-alloc
index e69de29..d8c8b91 100644
--- a/questions/ll-alloc
+++ b/questions/ll-alloc
@@ -0,0 +1 @@
+It saves the list pointers in place. Because we are implementing the allocator, it's hard to dynamically allocate some space for storing the linked list.
diff --git a/questions/manual-lookup b/questions/manual-lookup
index e69de29..ec87f2c 100644
--- a/questions/manual-lookup
+++ b/questions/manual-lookup
@@ -0,0 +1,4 @@
+To get /a/b/c.txt:
+Get root directory, from its entries, find one dir nameb a;
+Use /a, from its entries, find one dir named b;
+Use /a/b, from its entries, find one file named c.txt.
diff --git a/questions/mbr-magic b/questions/mbr-magic
index e69de29..821e7eb 100644
--- a/questions/mbr-magic
+++ b/questions/mbr-magic
@@ -0,0 +1 @@
+Last two bytes should be 0x55, 0xAA.
diff --git a/questions/onus b/questions/onus
index e69de29..86c3e80 100644
--- a/questions/onus
+++ b/questions/onus
@@ -0,0 +1 @@
+In C, the size is kept put before the memory address. In Rust, size and alignment is passed into `dealloc', so its implementation can be simplified, and size of the buffer is saved elsewhere e.g. len in String.
