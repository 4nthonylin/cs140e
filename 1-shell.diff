diff --git a/ferris-wheel/compile-fail/modules-1.rs b/ferris-wheel/compile-fail/modules-1.rs
index 3a19f4a..3f907bf 100644
--- a/ferris-wheel/compile-fail/modules-1.rs
+++ b/ferris-wheel/compile-fail/modules-1.rs
@@ -1,7 +1,7 @@
 // FIXME: Prevent this file from compiling! Diff budget: 1 line.
 
 mod a {
-    pub fn f() { }
+    fn f() { }
 }
 
 // Do not modify this function.
diff --git a/ferris-wheel/compile-fail/move.rs b/ferris-wheel/compile-fail/move.rs
index 78ffceb..6ddc8a5 100644
--- a/ferris-wheel/compile-fail/move.rs
+++ b/ferris-wheel/compile-fail/move.rs
@@ -1,5 +1,4 @@
 // FIXME: Prevent this file from compiling! Diff budget: 1 line.
-#[derive(Clone, Copy)]
 struct MyType(usize);
 
 // Note: do not modify this function.
diff --git a/ferris-wheel/compile-pass/borrow-1.rs b/ferris-wheel/compile-pass/borrow-1.rs
index 4fc3d1a..a8653b0 100644
--- a/ferris-wheel/compile-pass/borrow-1.rs
+++ b/ferris-wheel/compile-pass/borrow-1.rs
@@ -1,5 +1,6 @@
 // FIXME: Make me compile! Diff budget: 1 line.
 
+#[derive(Clone, Copy)]
 struct MyType(usize);
 
 // Do not modify this function.
diff --git a/ferris-wheel/compile-pass/const.rs b/ferris-wheel/compile-pass/const.rs
index 8419cb6..193dcef 100644
--- a/ferris-wheel/compile-pass/const.rs
+++ b/ferris-wheel/compile-pass/const.rs
@@ -1,8 +1,9 @@
 // FIXME: Make me compile! Diff budget: 3 lines.
+#![feature(const_fn)]
 
 const VAR: i32 = add(34, 10);
 
-fn add(a: i32, b: i32) -> i32 {
+const fn add(a: i32, b: i32) -> i32 {
     a + b
 }
 
diff --git a/ferris-wheel/compile-pass/derive.rs b/ferris-wheel/compile-pass/derive.rs
index 4410289..07c8aa6 100644
--- a/ferris-wheel/compile-pass/derive.rs
+++ b/ferris-wheel/compile-pass/derive.rs
@@ -1,4 +1,5 @@
 // FIXME: Make me compile! Diff budget: 1 line.
+#[derive(Debug, Clone, Copy)]
 enum Duration {
     MilliSeconds(u64),
     Seconds(u32),
diff --git a/ferris-wheel/compile-pass/feature-1.rs b/ferris-wheel/compile-pass/feature-1.rs
index f9aeb27..2bb86ad 100644
--- a/ferris-wheel/compile-pass/feature-1.rs
+++ b/ferris-wheel/compile-pass/feature-1.rs
@@ -1,4 +1,5 @@
 // FIXME: Make me compile! Diff budget: 2 lines.
+#![feature(i128_type)]
 // Do not modify this definition.
 enum Duration {
     MicroSeconds(u128),
diff --git a/ferris-wheel/compile-pass/io-read-write.rs b/ferris-wheel/compile-pass/io-read-write.rs
index a12a575..dfae9be 100644
--- a/ferris-wheel/compile-pass/io-read-write.rs
+++ b/ferris-wheel/compile-pass/io-read-write.rs
@@ -5,8 +5,8 @@ struct ReadWrapper<T: io::Read> {
     inner: T
 }
 
-impl io::Read for ReadWrapper<T> {
-    fn read(&mut self, buf: &mut [u8]) -> Result<usize> {
+impl<T: io::Read> io::Read for ReadWrapper<T> {
+    fn read(&mut self, buf: &mut [u8]) -> Result<usize, io::Error> {
         self.inner.read(buf)
     }
 }
diff --git a/ferris-wheel/compile-pass/lifetimes-1.rs b/ferris-wheel/compile-pass/lifetimes-1.rs
index 11e78c4..14356b5 100644
--- a/ferris-wheel/compile-pass/lifetimes-1.rs
+++ b/ferris-wheel/compile-pass/lifetimes-1.rs
@@ -3,7 +3,7 @@
 struct StrWrapper<'a>(&'a str);
 
 impl<'a> StrWrapper<'a> {
-    fn inner(&self) -> &str {
+    fn inner(&self) -> &'a str {
         self.0
     }
 }
diff --git a/ferris-wheel/compile-pass/lifetimes-2.rs b/ferris-wheel/compile-pass/lifetimes-2.rs
index e7a81cc..402a957 100644
--- a/ferris-wheel/compile-pass/lifetimes-2.rs
+++ b/ferris-wheel/compile-pass/lifetimes-2.rs
@@ -1,10 +1,10 @@
 // FIXME: Make me compile! Diff budget: 3 lines.
 
 // Do not modify the inner type &'a T.
-struct RefWrapper<T>(&'a T);
+struct RefWrapper<'a, T: 'a>(&'a T);
 
-impl RefWrapper {
-    fn inner(&self) -> &T {
+impl<'a, T> RefWrapper<'a, T> {
+    fn inner(&self) -> &'a T {
         self.0
     }
 }
diff --git a/ferris-wheel/compile-pass/lifetimes-3.rs b/ferris-wheel/compile-pass/lifetimes-3.rs
index 098b449..6f31ab6 100644
--- a/ferris-wheel/compile-pass/lifetimes-3.rs
+++ b/ferris-wheel/compile-pass/lifetimes-3.rs
@@ -1,9 +1,9 @@
 // FIXME: Make me compile! Diff budget: 2 lines.
 
 // Do not modify the inner type &'a T.
-struct RefWrapper<T>(&'a T);
+struct RefWrapper<'a, T: 'a>(&'a T);
 
 // Do not modify the inner type &'b RefWrapper<'a, T>.
-struct RefWrapperWrapper<T>(&'b RefWrapper<'a, T>);
+struct RefWrapperWrapper<'b, 'a : 'b, T: 'a>(&'b RefWrapper<'a, T>);
 
 pub fn main() { }
diff --git a/ferris-wheel/compile-pass/lifetimes-4.rs b/ferris-wheel/compile-pass/lifetimes-4.rs
index 95878c2..97883cc 100644
--- a/ferris-wheel/compile-pass/lifetimes-4.rs
+++ b/ferris-wheel/compile-pass/lifetimes-4.rs
@@ -1,12 +1,12 @@
 // FIXME: Make me compile! Diff budget: 3 lines.
 
 // Do not modify the inner type &'a T.
-struct RefWrapper<T>(&'a T);
+struct RefWrapper<'a, T: 'a>(&'a T);
 
 // Do not modify the inner type &'b RefWrapper<'a, T>.
-struct RefWrapperWrapper<T>(&'b RefWrapper<'a, T>);
+struct RefWrapperWrapper<'b, 'a: 'b, T: 'a>(&'b RefWrapper<'a, T>);
 
-impl RefWrapperWrapper {
+impl<'b, 'a, T> RefWrapperWrapper<'b, 'a, T> {
     fn inner(&self) -> &'a T {
         (self.0).0
     }
diff --git a/ferris-wheel/compile-pass/mutability-1.rs b/ferris-wheel/compile-pass/mutability-1.rs
index e304fe6..5b26954 100644
--- a/ferris-wheel/compile-pass/mutability-1.rs
+++ b/ferris-wheel/compile-pass/mutability-1.rs
@@ -1,5 +1,5 @@
 // FIXME: Make me compile! Diff budget: 1 line.
-fn make_1(v: &u32) {
+fn make_1(v: &mut u32) {
     *v = 1;
 }
 
diff --git a/ferris-wheel/compile-pass/mutability-2.rs b/ferris-wheel/compile-pass/mutability-2.rs
index a2e63f2..3d83256 100644
--- a/ferris-wheel/compile-pass/mutability-2.rs
+++ b/ferris-wheel/compile-pass/mutability-2.rs
@@ -1,6 +1,6 @@
 // FIXME: Make me compile! Diff budget: 1 line.
 
 pub fn main() {
-    let x = 10;
+    let x : &mut i32 = &mut 10; 
     *x = 20;
 }
diff --git a/ferris-wheel/compile-pass/mutability-3.rs b/ferris-wheel/compile-pass/mutability-3.rs
index 90e2d38..fcb94e9 100644
--- a/ferris-wheel/compile-pass/mutability-3.rs
+++ b/ferris-wheel/compile-pass/mutability-3.rs
@@ -1,6 +1,6 @@
 // FIXME: Make me compile! Diff budget: 1 line.
 
 pub fn main() {
-    let x = 10;
+    let mut x = 10;
     x = 20;
 }
diff --git a/ferris-wheel/compile-pass/mutability-4.rs b/ferris-wheel/compile-pass/mutability-4.rs
index 7acfc1c..d3b24e1 100644
--- a/ferris-wheel/compile-pass/mutability-4.rs
+++ b/ferris-wheel/compile-pass/mutability-4.rs
@@ -3,12 +3,12 @@
 struct MyStruct(usize);
 
 impl MyStruct {
-    fn make_1(&self) {
+    fn make_1(&mut self) {
         self.0 = 1;
     }
 }
 
 pub fn main() {
-    let x = MyStruct(10);
+    let mut x = MyStruct(10);
     x.make_1();
 }
diff --git a/ferris-wheel/compile-pass/pattern-match-1.rs b/ferris-wheel/compile-pass/pattern-match-1.rs
index 045b58e..817405f 100644
--- a/ferris-wheel/compile-pass/pattern-match-1.rs
+++ b/ferris-wheel/compile-pass/pattern-match-1.rs
@@ -8,8 +8,8 @@ enum MyEnum {
 
 fn matcher(val: &MyEnum) -> &str {
     match *val {
-        MyEnum::A(string) => string.as_str(),
-        MyEnum::B(string) => string.as_str()
+        MyEnum::A(ref string) => string.as_str(),
+        MyEnum::B(ref string) => string.as_str()
     }
 }
 
diff --git a/ferris-wheel/compile-pass/privacy.rs b/ferris-wheel/compile-pass/privacy.rs
index 34b36a2..cd82e3e 100644
--- a/ferris-wheel/compile-pass/privacy.rs
+++ b/ferris-wheel/compile-pass/privacy.rs
@@ -1,7 +1,7 @@
 // FIXME: Make me compile! Diff budget: 1 line.
 
 mod a {
-    fn f() { }
+    pub fn f() { }
 }
 
 // Do not modify this function.
diff --git a/ferris-wheel/compile-pass/semi.rs b/ferris-wheel/compile-pass/semi.rs
index c321b74..3e0b370 100644
--- a/ferris-wheel/compile-pass/semi.rs
+++ b/ferris-wheel/compile-pass/semi.rs
@@ -1,7 +1,7 @@
 // FIXME: Make me compile! Diff budget: 1 character.
 
 fn add(a: i32, b: i32) -> i32 {
-    a + b;
+    a + b
 }
 
 fn main() { }
diff --git a/ferris-wheel/compile-pass/trait-namespace.rs b/ferris-wheel/compile-pass/trait-namespace.rs
index 889fd1f..aed0c3e 100644
--- a/ferris-wheel/compile-pass/trait-namespace.rs
+++ b/ferris-wheel/compile-pass/trait-namespace.rs
@@ -11,6 +11,8 @@ mod a {
     impl MyTrait for MyType {  }
 }
 
+use a::MyTrait;
+
 // Do not modify this function.
 fn main() {
     let x = a::MyType;
diff --git a/ferris-wheel/compile-pass/try.rs b/ferris-wheel/compile-pass/try.rs
index 1bc6796..ab73a2b 100644
--- a/ferris-wheel/compile-pass/try.rs
+++ b/ferris-wheel/compile-pass/try.rs
@@ -4,7 +4,19 @@ struct ErrorB;
 
 enum Error {
     A(ErrorA),
-    B(ErrorB)
+    B(ErrorB),
+}
+
+impl std::convert::From<ErrorA> for Error {
+    fn from(e: ErrorA) -> Self {
+        Error::A(e)
+    }
+}
+
+impl std::convert::From<ErrorB> for Error {
+    fn from(e: ErrorB) -> Self {
+        Error::B(e)
+    }
 }
 
 fn do_a() -> Result<u16, ErrorA> {
@@ -16,7 +28,7 @@ fn do_b() -> Result<u32, ErrorB> {
 }
 
 fn do_both() -> Result<(u16, u32), Error> {
-    Ok((do_a(), do_b()))
+    Ok((do_a()?, do_b()?))
 }
 
-fn main() { }
+fn main() {}
diff --git a/ferris-wheel/questions/borrow-1 b/ferris-wheel/questions/borrow-1
index e69de29..88267a3 100644
--- a/ferris-wheel/questions/borrow-1
+++ b/ferris-wheel/questions/borrow-1
@@ -0,0 +1 @@
+Cannot move out of a borrowed content. Make it a ref.
\ No newline at end of file
diff --git a/ferris-wheel/questions/borrow-2 b/ferris-wheel/questions/borrow-2
index e69de29..38df2ea 100644
--- a/ferris-wheel/questions/borrow-2
+++ b/ferris-wheel/questions/borrow-2
@@ -0,0 +1 @@
+Rust does not allow mutable borrowing after a immutable borrowing in the same scope.
\ No newline at end of file
diff --git a/ferris-wheel/questions/builder b/ferris-wheel/questions/builder
index e69de29..18f2c22 100644
--- a/ferris-wheel/questions/builder
+++ b/ferris-wheel/questions/builder
@@ -0,0 +1 @@
+Implement the Builder design pattern for `Builder'.
\ No newline at end of file
diff --git a/ferris-wheel/questions/const b/ferris-wheel/questions/const
index e69de29..187ae5f 100644
--- a/ferris-wheel/questions/const
+++ b/ferris-wheel/questions/const
@@ -0,0 +1 @@
+Mark `add' as a const function (use feature to enable this unstable feature).
\ No newline at end of file
diff --git a/ferris-wheel/questions/derive b/ferris-wheel/questions/derive
index e69de29..7bbfb18 100644
--- a/ferris-wheel/questions/derive
+++ b/ferris-wheel/questions/derive
@@ -0,0 +1 @@
+Add #derive-s for `Duration'. `Debug' for output, `Copy' for multiple assignments and `Clone' for `Copy'.
\ No newline at end of file
diff --git a/ferris-wheel/questions/expressions b/ferris-wheel/questions/expressions
index e69de29..70fee07 100644
--- a/ferris-wheel/questions/expressions
+++ b/ferris-wheel/questions/expressions
@@ -0,0 +1 @@
+Implement a generic `max' function that uses `PartialOrd' as a type constraint.
\ No newline at end of file
diff --git a/ferris-wheel/questions/feature-1 b/ferris-wheel/questions/feature-1
index e69de29..566f4bd 100644
--- a/ferris-wheel/questions/feature-1
+++ b/ferris-wheel/questions/feature-1
@@ -0,0 +1 @@
+Add `i128_type' feature for the use of i128.
\ No newline at end of file
diff --git a/ferris-wheel/questions/io-read-write b/ferris-wheel/questions/io-read-write
index e69de29..e40c40a 100644
--- a/ferris-wheel/questions/io-read-write
+++ b/ferris-wheel/questions/io-read-write
@@ -0,0 +1 @@
+Add missing T and its constraint for the impl.
\ No newline at end of file
diff --git a/ferris-wheel/questions/lifetimes-1 b/ferris-wheel/questions/lifetimes-1
index e69de29..d07f245 100644
--- a/ferris-wheel/questions/lifetimes-1
+++ b/ferris-wheel/questions/lifetimes-1
@@ -0,0 +1 @@
+Make the return value of `inner' have the same lifetime as the wrapper itself. Then the compiler can deduce that all variables have the `static' lifetime.
\ No newline at end of file
diff --git a/ferris-wheel/questions/lifetimes-2 b/ferris-wheel/questions/lifetimes-2
index e69de29..cb4a3dc 100644
--- a/ferris-wheel/questions/lifetimes-2
+++ b/ferris-wheel/questions/lifetimes-2
@@ -0,0 +1 @@
+Add the corresponding generics for the `RefWrapper' and also the same lifetime for the type `T'.
\ No newline at end of file
diff --git a/ferris-wheel/questions/lifetimes-3 b/ferris-wheel/questions/lifetimes-3
index e69de29..19f3a95 100644
--- a/ferris-wheel/questions/lifetimes-3
+++ b/ferris-wheel/questions/lifetimes-3
@@ -0,0 +1 @@
+Add the corresponding generics for lifetimes. Here, `T' has a longer lifetime than `a', and `a' has a longer lifetime than `b', thus adding the lifetimes for them.
\ No newline at end of file
diff --git a/ferris-wheel/questions/lifetimes-4 b/ferris-wheel/questions/lifetimes-4
index e69de29..b239e6b 100644
--- a/ferris-wheel/questions/lifetimes-4
+++ b/ferris-wheel/questions/lifetimes-4
@@ -0,0 +1 @@
+Mostly the same as `lifetimes-3', just adding the generics for `RefWrapperWrapper'.
\ No newline at end of file
diff --git a/ferris-wheel/questions/modules-1 b/ferris-wheel/questions/modules-1
index e69de29..dcfe698 100644
--- a/ferris-wheel/questions/modules-1
+++ b/ferris-wheel/questions/modules-1
@@ -0,0 +1 @@
+Make `a::f' private prevents the program from compiling.
\ No newline at end of file
diff --git a/ferris-wheel/questions/move b/ferris-wheel/questions/move
index e69de29..ec0ac7f 100644
--- a/ferris-wheel/questions/move
+++ b/ferris-wheel/questions/move
@@ -0,0 +1 @@
+Remove the #derive-s of `MyType', so multiple moves make the program not compiling.
\ No newline at end of file
diff --git a/ferris-wheel/questions/mutability-1 b/ferris-wheel/questions/mutability-1
index e69de29..872ccdb 100644
--- a/ferris-wheel/questions/mutability-1
+++ b/ferris-wheel/questions/mutability-1
@@ -0,0 +1 @@
+Marking `v' mutable does the trick.
\ No newline at end of file
diff --git a/ferris-wheel/questions/mutability-2 b/ferris-wheel/questions/mutability-2
index e69de29..94cb938 100644
--- a/ferris-wheel/questions/mutability-2
+++ b/ferris-wheel/questions/mutability-2
@@ -0,0 +1 @@
+Replace `let x' with `let ref mut x' to make `x' a reference to a mutable integer. Using `&mut i32' as the type explicitly also does the trick.
\ No newline at end of file
diff --git a/ferris-wheel/questions/mutability-3 b/ferris-wheel/questions/mutability-3
index e69de29..2124347 100644
--- a/ferris-wheel/questions/mutability-3
+++ b/ferris-wheel/questions/mutability-3
@@ -0,0 +1 @@
+Replace `let x' with `let mut x' to make `x' a mutable integer.
\ No newline at end of file
diff --git a/ferris-wheel/questions/mutability-4 b/ferris-wheel/questions/mutability-4
index e69de29..1aabb73 100644
--- a/ferris-wheel/questions/mutability-4
+++ b/ferris-wheel/questions/mutability-4
@@ -0,0 +1 @@
+`self.0' is mutated, so `&self' should be mutable. Also, `x' needs to be mutable.
\ No newline at end of file
diff --git a/ferris-wheel/questions/pattern-match-1 b/ferris-wheel/questions/pattern-match-1
index e69de29..a19d5cc 100644
--- a/ferris-wheel/questions/pattern-match-1
+++ b/ferris-wheel/questions/pattern-match-1
@@ -0,0 +1 @@
+Use `ref' in pattern matching to prevent move and fix the lifetime error.
\ No newline at end of file
diff --git a/ferris-wheel/questions/privacy b/ferris-wheel/questions/privacy
index e69de29..57a47e8 100644
--- a/ferris-wheel/questions/privacy
+++ b/ferris-wheel/questions/privacy
@@ -0,0 +1 @@
+`a::f' should be public for `main' to call.
\ No newline at end of file
diff --git a/ferris-wheel/questions/semi b/ferris-wheel/questions/semi
index e69de29..e416572 100644
--- a/ferris-wheel/questions/semi
+++ b/ferris-wheel/questions/semi
@@ -0,0 +1 @@
+Remove the semicolon to make the result of the last expression to be the return value.
\ No newline at end of file
diff --git a/ferris-wheel/questions/trait-impl b/ferris-wheel/questions/trait-impl
index e69de29..2043eaf 100644
--- a/ferris-wheel/questions/trait-impl
+++ b/ferris-wheel/questions/trait-impl
@@ -0,0 +1 @@
+Implement trait `PartialEq' and `Debug' for `Duration'.
\ No newline at end of file
diff --git a/ferris-wheel/questions/trait-namespace b/ferris-wheel/questions/trait-namespace
index e69de29..f5481dc 100644
--- a/ferris-wheel/questions/trait-namespace
+++ b/ferris-wheel/questions/trait-namespace
@@ -0,0 +1 @@
+`use a::MyTrait' to introduce the `foo' into the current scope.
\ No newline at end of file
diff --git a/ferris-wheel/questions/try b/ferris-wheel/questions/try
index e69de29..6c180da 100644
--- a/ferris-wheel/questions/try
+++ b/ferris-wheel/questions/try
@@ -0,0 +1 @@
+Use `?' to propogate the error to the caller and get the result, then implementing `From' for automatically wrapping errors.
\ No newline at end of file
diff --git a/ferris-wheel/questions/ufcs b/ferris-wheel/questions/ufcs
index e69de29..d94bdcc 100644
--- a/ferris-wheel/questions/ufcs
+++ b/ferris-wheel/questions/ufcs
@@ -0,0 +1 @@
+Fix the name clashing by renaming one of the foo-s to foo2.
\ No newline at end of file
diff --git a/ferris-wheel/run-pass/borrow-2.rs b/ferris-wheel/run-pass/borrow-2.rs
index 58c8d09..3cd32e0 100644
--- a/ferris-wheel/run-pass/borrow-2.rs
+++ b/ferris-wheel/run-pass/borrow-2.rs
@@ -5,8 +5,10 @@ struct MyType(usize);
 
 pub fn main() {
     let mut x = MyType(1);
-    let y = &x;
-    assert_eq!(*y, MyType(1));
+    {
+        let y = &x;
+        assert_eq!(*y, MyType(1));
+    }
 
     // Do not modify this line.
     let x = &mut x;
diff --git a/ferris-wheel/run-pass/builder.rs b/ferris-wheel/run-pass/builder.rs
index 2c8dc7e..722017c 100644
--- a/ferris-wheel/run-pass/builder.rs
+++ b/ferris-wheel/run-pass/builder.rs
@@ -5,6 +5,38 @@ struct Builder {
     number: Option<usize>,
 }
 
+impl Builder {
+    fn default() -> Builder {
+        Builder {
+            string: None, 
+            number: None 
+        }
+    }
+
+    fn string<T: Into<String>>(&mut self, s: T) -> &mut Self {
+        self.string = Some(s.into())
+        self
+    }
+
+    fn number(&mut self, n: usize) -> &mut Self {
+        self.number = Some(n);
+        self
+    }
+}
+
+impl ToString for Builder {
+    fn to_string(&self) -> String {
+        [
+            &self.string,
+            &self.number.map(|x| x.to_string()),
+        ].iter()
+            .filter(|x| x.is_some())
+            .map(|&x| x.clone().unwrap())
+            .collect::<Vec<String>>()
+            .join(" ")
+    }
+}
+
 // Do not modify this function.
 fn main() {
     let empty = Builder::default().to_string();
@@ -31,9 +63,7 @@ fn main() {
 
     assert_eq!(b, "bye now! 200");
 
-    let c = Builder::default()
-        .string("heap!".to_owned())
-        .to_string();
+    let c = Builder::default().string("heap!".to_owned()).to_string();
 
     assert_eq!(c, "heap!");
 }
diff --git a/ferris-wheel/run-pass/expressions.rs b/ferris-wheel/run-pass/expressions.rs
index 5f0db05..7a1ebf4 100644
--- a/ferris-wheel/run-pass/expressions.rs
+++ b/ferris-wheel/run-pass/expressions.rs
@@ -5,6 +5,14 @@
 #[derive(Debug, PartialOrd, PartialEq, Clone, Copy)]
 struct IntWrapper(isize);
 
+fn max<T: PartialOrd>(a: T, b: T) -> T {
+    if a > b {
+        a
+    } else {
+        b
+    }
+}
+
 pub fn main() {
     assert_eq!(max(1usize, 3), 3);
     assert_eq!(max(1u8, 3), 3);
diff --git a/ferris-wheel/run-pass/trait-impl.rs b/ferris-wheel/run-pass/trait-impl.rs
index e0aba5b..eee0376 100644
--- a/ferris-wheel/run-pass/trait-impl.rs
+++ b/ferris-wheel/run-pass/trait-impl.rs
@@ -1,9 +1,30 @@
 // FIXME: Make me pass! Diff budget: 25 lines.
 
+#[derive(Debug)]
 enum Duration {
     MilliSeconds(u64),
     Seconds(u32),
-    Minutes(u16)
+    Minutes(u16),
+}
+
+use Duration::MilliSeconds;
+use Duration::Seconds;
+use Duration::Minutes;
+
+impl PartialEq for Duration {
+    fn eq(&self, other: &Duration) -> bool {
+        let a: u64 = match self {
+            &Duration::MilliSeconds(m) => m,
+            &Duration::Seconds(s) => s as u64 * 1000,
+            &Duration::Minutes(m) => m as u64 * 60000,
+        };
+        let b: u64 = match other {
+            &Duration::MilliSeconds(m) => m,
+            &Duration::Seconds(s) => s as u64 * 1000,
+            &Duration::Minutes(m) => m as u64 * 60000,
+        };
+        a == b
+    }
 }
 
 fn main() {
diff --git a/ferris-wheel/run-pass/ufcs.rs b/ferris-wheel/run-pass/ufcs.rs
index 319b54b..a5b576b 100644
--- a/ferris-wheel/run-pass/ufcs.rs
+++ b/ferris-wheel/run-pass/ufcs.rs
@@ -17,8 +17,8 @@ impl FooToo for Dummy { }
 fn main() {
     let dummy = Dummy;
 
-    let x = dummy.foo();
-    let y = dummy.foo();
+    let x = Foo::foo(&dummy);
+    let y = FooToo::foo(&dummy);
 
     // Values for `x` and `y` must come from calling `foo()` methods.
     assert_eq!(x, 1);
diff --git a/getting-started/questions/assignment0 b/getting-started/questions/assignment0
index e69de29..57165ed 100644
--- a/getting-started/questions/assignment0
+++ b/getting-started/questions/assignment0
@@ -0,0 +1 @@
+GPIO27: GPFSEL2, GPSET0, GPCLR0, Pin 13 on the left
\ No newline at end of file
diff --git a/questions/blinky-states b/questions/blinky-states
index e69de29..774e963 100644
--- a/questions/blinky-states
+++ b/questions/blinky-states
@@ -0,0 +1 @@
+START -> OUTPUT -> SET -> CLEAR -> SET -> CLEAR -> ...
diff --git a/questions/drop-container b/questions/drop-container
index e69de29..697b80a 100644
--- a/questions/drop-container
+++ b/questions/drop-container
@@ -0,0 +1 @@
+If multiple mutable references to a singleton exists, data race safety can no longer be guaranteed. By using a mutex, only one thread at a time can acquire the mutable reference.
diff --git a/questions/fake-states b/questions/fake-states
index e69de29..babd3c9 100644
--- a/questions/fake-states
+++ b/questions/fake-states
@@ -0,0 +1 @@
+If user faked a GPIO pin to state `Input', but the pin has not been initialized to allow input, it would disobey the hardware's spec.
diff --git a/questions/write-fmt b/questions/write-fmt
index e69de29..0d374e1 100644
--- a/questions/write-fmt
+++ b/questions/write-fmt
@@ -0,0 +1 @@
+`write_fmt' comes from the default implementation in trait `alloc::fmt::Write', which calls`write_str' to print the result into UART.
diff --git a/stack-vec/questions/clone-for-pop b/stack-vec/questions/clone-for-pop
index e69de29..8e6d930 100644
--- a/stack-vec/questions/clone-for-pop
+++ b/stack-vec/questions/clone-for-pop
@@ -0,0 +1 @@
+Because items in the array cannot be moved out of the array.
\ No newline at end of file
diff --git a/stack-vec/questions/deref-in-tests b/stack-vec/questions/deref-in-tests
index e69de29..0b971dc 100644
--- a/stack-vec/questions/deref-in-tests
+++ b/stack-vec/questions/deref-in-tests
@@ -0,0 +1,3 @@
+The indexing and `iter()' methods requires `Deref' and sometimes `DerefMut' to convert a `StackVec' to a slice, which has the corresponding methods to call. It can be seen that `StackVec' act as a smart pointer to the underlying array.
+Because `DerefMut' relies on `Deref', without both, all indexing tests and iterator test fail to compile. 
+With only `Deref', mutable indexing test will fail to compile.
\ No newline at end of file
diff --git a/stack-vec/questions/lifetime b/stack-vec/questions/lifetime
index e69de29..49e7c78 100644
--- a/stack-vec/questions/lifetime
+++ b/stack-vec/questions/lifetime
@@ -0,0 +1 @@
+Because the type itself has its lifetime, too, and the type must outlive the objects of it.
\ No newline at end of file
diff --git a/stack-vec/questions/push-fails b/stack-vec/questions/push-fails
index e69de29..41bdbb2 100644
--- a/stack-vec/questions/push-fails
+++ b/stack-vec/questions/push-fails
@@ -0,0 +1 @@
+Because `StackVec' uses a fixed stack memory for storing its items, but `Vec' expands its allocated memory region when necessary.
\ No newline at end of file
diff --git a/stack-vec/src/lib.rs b/stack-vec/src/lib.rs
index bbec5aa..d364ed6 100644
--- a/stack-vec/src/lib.rs
+++ b/stack-vec/src/lib.rs
@@ -4,6 +4,8 @@
 #[cfg(test)]
 mod tests;
 
+use core::ops::{Deref, DerefMut};
+
 /// A contiguous array type backed by a slice.
 ///
 /// `StackVec`'s functionality is similar to that of `std::Vec`. You can `push`
@@ -15,7 +17,7 @@ mod tests;
 #[derive(Debug)]
 pub struct StackVec<'a, T: 'a> {
     storage: &'a mut [T],
-    len: usize
+    len: usize,
 }
 
 impl<'a, T: 'a> StackVec<'a, T> {
@@ -23,7 +25,10 @@ impl<'a, T: 'a> StackVec<'a, T> {
     /// store. The returned `StackVec` will be able to hold `storage.len()`
     /// values.
     pub fn new(storage: &'a mut [T]) -> StackVec<'a, T> {
-        unimplemented!()
+        StackVec {
+            len: 0,
+            storage: storage,
+        }
     }
 
     /// Constructs a new `StackVec<T>` using `storage` as the backing store. The
@@ -35,19 +40,27 @@ impl<'a, T: 'a> StackVec<'a, T> {
     ///
     /// Panics if `len > storage.len()`.
     pub fn with_len(storage: &'a mut [T], len: usize) -> StackVec<'a, T> {
-        unimplemented!()
+        if len > storage.len() {
+            panic!("len should not be greather than storage.len()")
+        }
+        StackVec {
+            len: len,
+            storage: storage,
+        }
     }
 
     /// Returns the number of elements this vector can hold.
     pub fn capacity(&self) -> usize {
-        unimplemented!()
+        self.storage.len()
     }
 
     /// Shortens the vector, keeping the first `len` elements. If `len` is
     /// greater than the vector's current length, this has no effect. Note that
     /// this method has no effect on the capacity of the vector.
     pub fn truncate(&mut self, len: usize) {
-        unimplemented!()
+        if self.len > len {
+            self.len = len
+        }
     }
 
     /// Extracts a slice containing the entire vector, consuming `self`.
@@ -55,33 +68,33 @@ impl<'a, T: 'a> StackVec<'a, T> {
     /// Note that the returned slice's length will be the length of this vector,
     /// _not_ the length of the original backing storage.
     pub fn into_slice(self) -> &'a mut [T] {
-        unimplemented!()
+        &mut self.storage[0..self.len]
     }
 
     /// Extracts a slice containing the entire vector.
     pub fn as_slice(&self) -> &[T] {
-        unimplemented!()
+        &self.storage[0..self.len]
     }
 
     /// Extracts a mutable slice of the entire vector.
     pub fn as_mut_slice(&mut self) -> &mut [T] {
-        unimplemented!()
+        &mut self.storage[0..self.len]
     }
 
     /// Returns the number of elements in the vector, also referred to as its
     /// 'length'.
     pub fn len(&self) -> usize {
-        unimplemented!()
+        self.len
     }
 
     /// Returns true if the vector contains no elements.
     pub fn is_empty(&self) -> bool {
-        unimplemented!()
+        self.len == 0
     }
 
     /// Returns true if the vector is at capacity.
     pub fn is_full(&self) -> bool {
-        unimplemented!()
+        self.len == self.storage.len()
     }
 
     /// Appends `value` to the back of this vector if the vector is not full.
@@ -91,7 +104,13 @@ impl<'a, T: 'a> StackVec<'a, T> {
     /// If this vector is full, an `Err` is returned. Otherwise, `Ok` is
     /// returned.
     pub fn push(&mut self, value: T) -> Result<(), ()> {
-        unimplemented!()
+        if self.len == self.storage.len() {
+            Err(())
+        } else {
+            self.storage[self.len] = value;
+            self.len += 1;
+            Ok(())
+        }
     }
 }
 
@@ -99,9 +118,161 @@ impl<'a, T: Clone + 'a> StackVec<'a, T> {
     /// If this vector is not empty, removes the last element from this vector
     /// by cloning it and returns it. Otherwise returns `None`.
     pub fn pop(&mut self) -> Option<T> {
-        unimplemented!()
+        if self.len > 0 {
+            self.len -= 1;
+            Some(self.storage[self.len].clone())
+        } else {
+            None
+        }
     }
 }
 
 // FIXME: Implement `Deref`, `DerefMut`, and `IntoIterator` for `StackVec`.
+
+impl<'a, T: 'a> Deref for StackVec<'a, T> {
+    type Target = [T];
+
+    fn deref(&self) -> &Self::Target {
+        &self.storage[0..self.len]
+    }
+}
+
+impl<'a, T: 'a> DerefMut for StackVec<'a, T> {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.storage[0..self.len]
+    }
+}
+
+impl<'a, T: 'a> IntoIterator for StackVec<'a, T> {
+    type Item = &'a T;
+    type IntoIter = ::core::slice::Iter<'a, T>;
+
+    fn into_iter(self) -> Self::IntoIter {
+        self.storage[0..self.len].into_iter()
+    }
+}
+
+/* Alternative solution:
+pub struct StackVecIntoIterator<'a, T: 'a> {
+    index: usize,
+    vec: StackVec<'a, T>,
+}
+
+impl<'a, T: 'a> StackVecIntoIterator<'a, T> {
+    fn new(sv: StackVec<'a, T>) -> StackVecIntoIterator<'a, T> {
+        StackVecIntoIterator { index: 0, vec: sv }
+    }
+}
+
+pub struct RefWrapper<T> {
+    element: T,
+}
+
+impl<T> Deref for RefWrapper<T> {
+    type Target = T;
+    fn deref(&self) -> &Self::Target {
+        &self.element
+    }
+}
+
+impl<'a, T: 'a + Clone> Iterator for StackVecIntoIterator<'a, T> {
+    type Item = RefWrapper<T>;
+
+    fn next(&mut self) -> Option<Self::Item> {
+        if self.index < self.vec.len {
+            self.index += 1;
+            Some(RefWrapper {
+                element: self.vec[self.index - 1].clone(),
+            })
+        } else {
+            None
+        }
+    }
+}
+
+impl<'a, T: 'a + Clone> IntoIterator for StackVec<'a, T> {
+    type Item = RefWrapper<T>;
+    type IntoIter = StackVecIntoIterator<'a, T>;
+
+    fn into_iter(self) -> Self::IntoIter {
+        StackVecIntoIterator::new(self)
+    }
+}
+*/
+
 // FIXME: Implement IntoIterator` for `&StackVec`.
+
+impl<'a, T: 'a> IntoIterator for &'a StackVec<'a, T> {
+    type Item = &'a T;
+    type IntoIter = ::core::slice::Iter<'a, T>;
+
+    fn into_iter(self) -> Self::IntoIter {
+        self.storage[0..self.len].into_iter()
+    }
+}
+
+/* Alternative implementation:
+pub struct StackVecIterator<'a, T: 'a> {
+    index: usize,
+    vec: &'a StackVec<'a, T>,
+}
+
+impl<'a, T: 'a> StackVecIterator<'a, T> {
+    fn new(sv: &'a StackVec<'a, T>) -> StackVecIterator<'a, T> {
+        StackVecIterator { index: 0, vec: sv }
+    }
+}
+
+impl<'a, T: 'a> Iterator for StackVecIterator<'a, T> {
+    type Item = &'a T;
+
+    fn next(&mut self) -> Option<Self::Item> {
+        if self.index < self.vec.len {
+            self.index += 1;
+            Some(&self.vec[self.index - 1])
+        } else {
+            None
+        }
+    }
+}
+
+impl<'a, T: 'a> IntoIterator for &'a StackVec<'a, T> {
+    type Item = &'a T;
+    type IntoIter = StackVecIterator<'a, T>;
+
+    fn into_iter(self) -> Self::IntoIter {
+        Self::IntoIter::new(&self)
+    }
+}
+*/
+
+// My helper functions
+impl<'a, T: Clone> StackVec<'a, T> {
+    pub fn remove(&mut self, index: usize) -> T {
+        if index >= self.len {
+            panic!("index out of bound")
+        }
+
+        let item = self.storage[index].clone();
+        self.len -= 1;
+
+        for i in index..self.len {
+            self.storage[i] = self.storage[i+1].clone();
+        }
+
+        item
+    }
+
+    pub fn insert(&mut self, index: usize, element: T) -> Result<(), ()> {
+        if self.len == self.storage.len() || index > self.len() {
+            Err(())
+        } else {
+            for i in (index..self.len).rev() {
+                self.storage[i+1] = self.storage[i].clone()
+            }
+            self.storage[index] = element;
+            self.len += 1;
+            Ok(())
+        }
+    }
+}
diff --git a/stack-vec/src/tests.rs b/stack-vec/src/tests.rs
index 2b860cc..d37d000 100644
--- a/stack-vec/src/tests.rs
+++ b/stack-vec/src/tests.rs
@@ -202,3 +202,18 @@ fn as_slice() {
     assert_eq!(stack_vec.as_slice(), &[102]);
     assert_eq!(stack_vec.as_mut_slice(), &mut [102]);
 }
+
+#[test] 
+fn remove_insert() {
+    let mut storage = [0, 1, 2, 3, 4, 5];
+    let mut stack_vec = StackVec::with_len(&mut storage, 6);
+    stack_vec.remove(0);
+    assert_eq!(stack_vec.as_slice(), &[1, 2, 3, 4, 5]);
+    stack_vec.insert(0, 6).expect("cap 6");
+    assert_eq!(stack_vec.as_slice(), &[6, 1, 2, 3, 4, 5]);
+    assert!(stack_vec.insert(2, 0).is_err());
+    stack_vec.remove(1);
+    assert_eq!(stack_vec.as_slice(), &[6, 2, 3, 4, 5]);
+    stack_vec.insert(5, 0).expect("cap 6");
+    assert_eq!(stack_vec.as_slice(), &[6, 2, 3, 4, 5, 0]);
+}
diff --git a/ttywrite/src/main.rs b/ttywrite/src/main.rs
index 08d89e8..eba3573 100644
--- a/ttywrite/src/main.rs
+++ b/ttywrite/src/main.rs
@@ -47,6 +47,10 @@ struct Opt {
     raw: bool,
 }
 
+fn progress_fn(progress: Progress) {
+    println!("Progress: {:?}", progress);
+}
+
 fn main() {
     use std::fs::File;
     use std::io::{self, BufReader, BufRead};
@@ -55,4 +59,36 @@ fn main() {
     let mut serial = serial::open(&opt.tty_path).expect("path points to invalid TTY");
 
     // FIXME: Implement the `ttywrite` utility.
+    let mut settings = serial.read_settings().expect("device should be valid");
+    settings.set_baud_rate(opt.baud_rate).expect("baud rate should be valid");
+    settings.set_stop_bits(opt.stop_bits);
+    settings.set_flow_control(opt.flow_control);
+    settings.set_char_size(opt.char_width);
+    serial.write_settings(&settings).expect("settings should be valid");
+    serial.set_timeout(Duration::new(opt.timeout, 0)).expect("timeout should be valid");
+
+    if opt.raw {
+        match opt.input {
+            Some(ref path) => {
+                let mut input = File::open(path).expect("file should exist");
+                io::copy(&mut input, &mut serial).expect("io transfer should succeed");
+            },
+            None => {
+                let mut input = io::stdin();
+                io::copy(&mut input, &mut serial).expect("io transfer should succeed");
+            }
+        };
+    } else {
+        // XMODEM
+        match opt.input {
+            Some(ref path) => {
+                let mut input = File::open(path).expect("file should exist");
+                Xmodem::transmit_with_progress(input, serial, progress_fn).expect("xmodem transfer should succeed");
+            },
+            None => {
+                let mut input = io::stdin();
+                Xmodem::transmit_with_progress(input, serial, progress_fn).expect("xmodem transfer should succeed");
+            }
+        };
+    }
 }
diff --git a/ttywrite/test.sh b/ttywrite/test.sh
index 4463494..b068e9b 100755
--- a/ttywrite/test.sh
+++ b/ttywrite/test.sh
@@ -34,8 +34,9 @@ socat -u ${PARAMS},link=input ${PARAMS},link=output &
 sleep 1
 
 if [[ "$(uname)" = "Darwin" ]]; then
-  stty -f input min 0 time 1
-  stty -f output min 0 time 1
+  # having GNU coreutils in my PATH
+  stty -F input min 0 time 1
+  stty -F output min 0 time 1
 else
   stty -F input min 0 time 1
   stty -F output min 0 time 1
diff --git a/volatile/questions/enforcing b/volatile/questions/enforcing
index e69de29..9e2ce79 100644
--- a/volatile/questions/enforcing
+++ b/volatile/questions/enforcing
@@ -0,0 +1 @@
+The inner pointer field `self.0' is not public, thus can only be accessed indirectly by its public functions. `ReadVolatile' provides `read' and returns a const pointer to T for `inner'. `WriteVolatile' provides `write' but returns a mutable pointer to T for `inner', which might allow reading the pointer in fact.
\ No newline at end of file
diff --git a/volatile/questions/macros b/volatile/questions/macros
index e69de29..f60f83c 100644
--- a/volatile/questions/macros
+++ b/volatile/questions/macros
@@ -0,0 +1 @@
+These macros are helpers to help implement those trait for `Volatile'-s.
\ No newline at end of file
diff --git a/volatile/questions/pub-constructor b/volatile/questions/pub-constructor
index e69de29..f65c214 100644
--- a/volatile/questions/pub-constructor
+++ b/volatile/questions/pub-constructor
@@ -0,0 +1 @@
+In this way, `self.0' can be accessed directly from the outside of the library, thus the safety implications can no longer hold.
\ No newline at end of file
diff --git a/volatile/questions/safety b/volatile/questions/safety
index e69de29..935c167 100644
--- a/volatile/questions/safety
+++ b/volatile/questions/safety
@@ -0,0 +1 @@
+Because, `read' and `write' have no raw pointers in their function signature, yet `new' needs a raw pointer passed in.
\ No newline at end of file
diff --git a/volatile/questions/traits b/volatile/questions/traits
index e69de29..3f75dff 100644
--- a/volatile/questions/traits
+++ b/volatile/questions/traits
@@ -0,0 +1 @@
+By using these traits, the default implementation included in these traits reuses much code and allow for cleaner implementation for `Volatile'-s. However, the `new' methods have to have different type signature for different semantics, so they cannot be put into a trait, but they still provide a similar interface. It eases using the library and prevents the library author from making errors.
\ No newline at end of file
diff --git a/volatile/questions/unique-volatile b/volatile/questions/unique-volatile
index e69de29..ae3aa4c 100644
--- a/volatile/questions/unique-volatile
+++ b/volatile/questions/unique-volatile
@@ -0,0 +1 @@
+`UniqueVolatile' means no pointer aliasing i.e. only one `UniqueVolatile' corresponds to the underlying pointer, allowing it to be thread safe. On the other side, `Volatile' does not have this restriction.
\ No newline at end of file
diff --git a/xmodem/src/lib.rs b/xmodem/src/lib.rs
index c6ce954..a92c939 100644
--- a/xmodem/src/lib.rs
+++ b/xmodem/src/lib.rs
@@ -173,7 +173,18 @@ impl<T: io::Read + io::Write> Xmodem<T> {
     /// byte was not `byte`, if the read byte was `CAN` and `byte` is not `CAN`,
     /// or if writing the `CAN` byte failed on byte mismatch.
     fn expect_byte_or_cancel(&mut self, byte: u8, msg: &'static str) -> io::Result<u8> {
-        unimplemented!()
+        let byte_in = self.read_byte(false)?;
+
+        if byte_in == byte {
+            Ok(byte)
+        } else {
+            self.write_byte(CAN)?;
+            if byte_in == CAN {
+                Err(io::Error::new(io::ErrorKind::ConnectionAborted, "received CAN"))
+            } else {
+                Err(io::Error::new(io::ErrorKind::InvalidData, msg))
+            }
+        }
     }
 
     /// Reads a single byte from the inner I/O stream and compares it to `byte`.
@@ -188,7 +199,17 @@ impl<T: io::Read + io::Write> Xmodem<T> {
     /// of `ConnectionAborted` is returned. Otherwise, the error kind is
     /// `InvalidData`.
     fn expect_byte(&mut self, byte: u8, expected: &'static str) -> io::Result<u8> {
-        unimplemented!()
+        let byte_in = self.read_byte(false)?;
+
+        if byte_in == byte {
+            Ok(byte)
+        } else {
+            if byte_in == CAN {
+                Err(io::Error::new(io::ErrorKind::ConnectionAborted, "received CAN"))
+            } else {
+                Err(io::Error::new(io::ErrorKind::InvalidData, expected))
+            }
+        }
     }
 
     /// Reads (downloads) a single packet from the inner stream using the XMODEM
@@ -215,7 +236,48 @@ impl<T: io::Read + io::Write> Xmodem<T> {
     ///
     /// An error of kind `UnexpectedEof` is returned if `buf.len() < 128`.
     pub fn read_packet(&mut self, buf: &mut [u8]) -> io::Result<usize> {
-        unimplemented!()
+        if buf.len() < 128 {
+            return Err(io::Error::new(io::ErrorKind::UnexpectedEof, "buf.len() should not be less than 129"))
+        }
+
+        if self.started == false {
+            self.write_byte(NAK)?;
+            self.started = true;
+            (self.progress)(Progress::Started);
+        }
+
+        match self.read_byte(true)? {
+            EOT => {
+                self.write_byte(NAK)?;
+                self.expect_byte(EOT, "expected EOT for end of transmission")?;
+                self.write_byte(ACK)?;
+                self.started = false;
+                Ok(0)
+            },
+            SOH => {
+                let packet = self.packet;
+                self.expect_byte_or_cancel(packet, "packet number wrong")?;
+                self.expect_byte_or_cancel(!packet, "packet number checksum failed")?;
+
+                let mut checksum: u8 = 0;
+                for byte in buf {
+                    *byte = self.read_byte(false)?;
+                    checksum = checksum.wrapping_add(*byte);
+                }
+
+                if self.read_byte(false)? != checksum {
+                    self.write_byte(NAK)?;
+                    Err(io::Error::new(io::ErrorKind::Interrupted, "packet data checksum failed"))
+                } else {
+                    self.write_byte(ACK)?;
+
+                    (self.progress)(Progress::Packet(self.packet));
+                    self.packet = self.packet.wrapping_add(1);
+                    Ok(128)
+                }
+            }
+            _ => Err(io::Error::new(io::ErrorKind::InvalidData, "expected SOH or EOT"))
+        }
     }
 
     /// Sends (uploads) a single packet to the inner stream using the XMODEM
@@ -249,7 +311,49 @@ impl<T: io::Read + io::Write> Xmodem<T> {
     ///
     /// An error of kind `Interrupted` is returned if a packet checksum fails.
     pub fn write_packet(&mut self, buf: &[u8]) -> io::Result<usize> {
-        unimplemented!()
+        if buf.len() < 128 && buf.len() != 0 {
+            return Err(io::Error::new(io::ErrorKind::UnexpectedEof, "buf.len() should not be less than 128"));
+        }
+
+        if !self.started {
+            (self.progress)(Progress::Waiting);
+            self.expect_byte(NAK, "expected NAK to start transfer")?;
+            self.started = true;
+            (self.progress)(Progress::Started);
+        }
+
+        if buf.len() == 0 {
+            self.write_byte(EOT)?;
+            self.expect_byte(NAK, "expected NAK for EOT")?;
+            self.write_byte(EOT)?;
+            self.expect_byte(ACK, "expected ACK for EOT")?;
+            self.started = false;
+            return Ok(0);
+        }
+
+        let packet = self.packet;
+        self.write_byte(SOH)?;
+        self.write_byte(packet)?;
+        self.write_byte(!packet)?;
+
+        let mut checksum: u8 = 0;
+        for byte in buf {
+            self.write_byte(*byte)?;
+            checksum = checksum.wrapping_add(*byte);
+        }
+        self.write_byte(checksum)?;
+
+        let result = self.read_byte(true)?;
+        match result {
+            ACK => {
+                (self.progress)(Progress::Packet(self.packet));
+                self.packet = self.packet.wrapping_add(1);
+                Ok(buf.len())
+            },
+            NAK => Err(io::Error::new(io::ErrorKind::Interrupted, "data corrupted from receiver")),
+            _ => Err(io::Error::new(io::ErrorKind::InvalidData, "expected ACK or NAK"))
+        }
+
     }
 
     /// Flush this output stream, ensuring that all intermediately buffered
