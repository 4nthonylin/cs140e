diff --git a/bootloader/src/kmain.rs b/bootloader/src/kmain.rs
index 591a219..59e3ebc 100644
--- a/bootloader/src/kmain.rs
+++ b/bootloader/src/kmain.rs
@@ -1,7 +1,11 @@
 #![feature(asm, lang_items)]
 
-extern crate xmodem;
 extern crate pi;
+extern crate xmodem;
+
+use std::io;
+use std::io::Write;
+use pi::uart::MiniUart;
 
 pub mod lang_items;
 
@@ -19,11 +23,31 @@ const MAX_BINARY_SIZE: usize = BOOTLOADER_START_ADDR - BINARY_START_ADDR;
 fn jump_to(addr: *mut u8) -> ! {
     unsafe {
         asm!("br $0" : : "r"(addr as usize));
-        loop { asm!("nop" :::: "volatile")  }
+        loop {
+            asm!("nop" :::: "volatile")
+        }
     }
 }
 
 #[no_mangle]
 pub extern "C" fn kmain() {
     // FIXME: Implement the bootloader.
+    let mut uart = MiniUart::new();
+    uart.set_read_timeout(750);
+
+    loop {
+        let dest = unsafe { std::slice::from_raw_parts_mut(BINARY_START, MAX_BINARY_SIZE) };
+        match xmodem::Xmodem::receive(&mut uart, io::Cursor::new(dest)) {
+            Ok(_) => {
+                // Succeed
+                jump_to(BINARY_START)
+            }
+            Err(err) => match err.kind() {
+                io::ErrorKind::TimedOut => continue,
+                io::ErrorKind::InvalidData => continue, // might receive 0x00 when no input
+                _ => uart.write_fmt(format_args!("Error: {:?}\r\n", err))
+                    .unwrap(),
+            },
+        }
+    }
 }
diff --git a/kernel/src/console.rs b/kernel/src/console.rs
index 557772e..f131773 100644
--- a/kernel/src/console.rs
+++ b/kernel/src/console.rs
@@ -19,35 +19,36 @@ impl Console {
     /// Initializes the console if it's not already initialized.
     #[inline]
     fn initialize(&mut self) {
-        unimplemented!()
+        self.inner.get_or_insert_with(&MiniUart::new);
     }
 
     /// Returns a mutable borrow to the inner `MiniUart`, initializing it as
     /// needed.
     fn inner(&mut self) -> &mut MiniUart {
-        unimplemented!()
+        self.initialize();
+        self.inner.as_mut().unwrap()
     }
 
     /// Reads a byte from the UART device, blocking until a byte is available.
     pub fn read_byte(&mut self) -> u8 {
-        unimplemented!()
+        self.inner().read_byte()
     }
 
     /// Writes the byte `byte` to the UART device.
     pub fn write_byte(&mut self, byte: u8) {
-        unimplemented!()
+        self.inner().write_byte(byte)
     }
 }
 
 impl io::Read for Console {
     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
-        unimplemented!()
+        self.inner().read(buf)
     }
 }
 
 impl io::Write for Console {
     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
-        unimplemented!()
+        self.inner().write(buf)
     }
 
     fn flush(&mut self) -> io::Result<()> {
@@ -57,7 +58,7 @@ impl io::Write for Console {
 
 impl fmt::Write for Console {
     fn write_str(&mut self, s: &str) -> fmt::Result {
-        unimplemented!()
+        self.inner().write_str(s)
     }
 }
 
diff --git a/kernel/src/kmain.rs b/kernel/src/kmain.rs
index 9eacec9..d22fa53 100644
--- a/kernel/src/kmain.rs
+++ b/kernel/src/kmain.rs
@@ -4,7 +4,6 @@
 #![feature(asm)]
 #![feature(optin_builtin_traits)]
 #![feature(decl_macro)]
-#![feature(repr_align)]
 #![feature(attr_literals)]
 #![feature(never_type)]
 #![feature(ptr_internals)]
@@ -12,12 +11,61 @@
 extern crate pi;
 extern crate stack_vec;
 
+use pi::gpio::Gpio;
+use std::fmt::Write;
+use pi::uart::MiniUart;
+use pi::timer::spin_sleep_ms;
+use pi::timer::current_time;
+
 pub mod lang_items;
 pub mod mutex;
 pub mod console;
 pub mod shell;
 
+use console::{kprintln, CONSOLE};
+
+fn blinky() {
+    let pin16 = Gpio::new(16);
+    let mut pin_out16 = pin16.into_output();
+
+    loop {
+        pin_out16.set();
+        spin_sleep_ms(1000);
+        pin_out16.clear();
+        spin_sleep_ms(1000);
+    }
+}
+
+fn echo() {
+    let mut uart = MiniUart::new();
+
+    loop {
+        let byte = uart.read_byte();
+        uart.write_byte(byte);
+    }
+}
+
+fn time() {
+    loop {
+        kprintln!("Current time: {}", current_time());
+        spin_sleep_ms(1000);
+    }
+}
+
+fn hex() {
+    let mut console = CONSOLE.lock();
+    loop {
+        let byte = console.read_byte();
+        console.write_fmt(format_args!("{:#X}", byte)).unwrap();
+    }
+}
+
 #[no_mangle]
 pub extern "C" fn kmain() {
     // FIXME: Start the shell.
+    // blinky();
+    // echo();
+    // time();
+    // hex();
+    shell::shell("> ");
 }
diff --git a/kernel/src/shell.rs b/kernel/src/shell.rs
index 03fb8fb..0d0b1fe 100644
--- a/kernel/src/shell.rs
+++ b/kernel/src/shell.rs
@@ -1,16 +1,39 @@
 use stack_vec::StackVec;
 use console::{kprint, kprintln, CONSOLE};
+use std::str;
+use pi::timer::{spin_sleep_ms, current_time};
 
 /// Error type for `Command` parse failures.
 #[derive(Debug)]
 enum Error {
     Empty,
-    TooManyArgs
+    TooManyArgs,
 }
 
+const BEL: u8 = 0x07u8;
+const BS: u8 = 0x08u8;
+const LF: u8 = 0x0au8;
+const CR: u8 = 0x0du8;
+const ESC: u8 = 0x1bu8;
+const DEL: u8 = 0x7fu8;
+
+const BANNER: &str = r#"
+                 _ _ ___         
+             __-         `-_    
+         ___/__        ã€‡   \ 
+     - '     _/             /
+   '_'             /
+ / _- ---            __ -
+/`     |          _ / \  \
+       |       -       \ |
+        \    /          V
+          \  |
+            \ \
+              \"#;
+
 /// A structure representing a single shell command.
 struct Command<'a> {
-    args: StackVec<'a, &'a str>
+    args: StackVec<'a, &'a str>,
 }
 
 impl<'a> Command<'a> {
@@ -36,12 +59,189 @@ impl<'a> Command<'a> {
 
     /// Returns this command's path. This is equivalent to the first argument.
     fn path(&self) -> &str {
-        unimplemented!()
+        self.args[0]
     }
 }
 
 /// Starts a shell using `prefix` as the prefix for each line. This function
 /// never returns: it is perpetually in a shell loop.
 pub fn shell(prefix: &str) -> ! {
-    unimplemented!()
+    spin_sleep_ms(500); // wait for client to attach
+    kprintln!("{}", BANNER);
+
+    let mut buffer = [0u8; 512];
+    let mut line_vec = StackVec::new(&mut buffer);
+    loop {
+        let mut args_buf = [""; 64];
+        kprint!("{}", prefix);
+
+        line_vec.truncate(0);
+        let line = read_line(&mut line_vec);
+
+        match Command::parse(line, &mut args_buf) {
+            Ok(command) => {
+                let path = command.path();
+                match path {
+                    "echo" => echo(&command),
+                    "echohex" => echohex(&command),
+                    "uptime" => uptime(&command),
+                    "exit" => exit(&command),
+                    _ => kprintln!("unknown command: {}", path),
+                }
+            }
+            Err(Error::Empty) => {
+                // Ignore
+            }
+            Err(Error::TooManyArgs) => {
+                kprintln!("error: too many arguments");
+            }
+        }
+    }
+}
+
+fn read_line<'a>(line_vec: &'a mut StackVec<u8>) -> &'a str {
+    let mut console = CONSOLE.lock();
+    let mut cursor = 0;
+    loop {
+        match console.read_byte() {
+            BS | DEL => {
+                // Backspace
+                if cursor > 0 {
+                    cursor -= 1;
+                    line_vec.remove(cursor);
+
+                    console.write_byte(BS);
+                    for byte in &line_vec[cursor..] {
+                        console.write_byte(*byte);
+                    }
+                    console.write_byte(b' ');
+                    for _i in cursor..line_vec.len() {
+                        console.write_byte(BS);
+                    }
+                    console.write_byte(BS);
+                } else {
+                    console.write_byte(BEL);
+                }
+            }
+            CR | LF => {
+                // Return
+                console.write_byte(CR);
+                console.write_byte(LF);
+                break;
+            }
+            ESC => {
+                match console.read_byte() {
+                    b'[' => {
+                        match console.read_byte() {
+                            b'D' => {
+                                // Left arrow
+                                if cursor > 0 {
+                                    cursor -= 1;
+                                    console.write_byte(ESC);
+                                    console.write_byte(b'[');
+                                    console.write_byte(b'D');
+                                } else {
+                                    console.write_byte(BEL);
+                                }
+                            }
+                            b'C' => {
+                                // Right arrow
+                                if cursor < line_vec.len() {
+                                    cursor += 1;
+                                    console.write_byte(ESC);
+                                    console.write_byte(b'[');
+                                    console.write_byte(b'C');
+                                } else {
+                                    console.write_byte(BEL);
+                                }
+                            }
+                            _ => {
+                                console.write_byte(BEL);
+                            }
+                        }
+                    }
+                    _ => {
+                        console.write_byte(BEL);
+                    }
+                }
+            }
+            byte if byte.is_ascii_graphic() || byte == b' ' => {
+                match line_vec.insert(cursor, byte) {
+                    Ok(()) => {
+                        for byte in &line_vec[cursor..] {
+                            console.write_byte(*byte);
+                        }
+                        cursor += 1;
+                        for _i in cursor..line_vec.len() {
+                            console.write_byte(BS);
+                        }
+                    }
+                    Err(()) => {
+                        // buffer full
+                        // might need better message?
+                        console.write_byte(BEL);
+                    }
+                }
+            }
+            _ => {
+                // unrecognized characters
+                console.write_byte(BEL);
+            }
+        }
+    }
+
+    str::from_utf8(line_vec.as_slice()).unwrap_or_default()
+}
+
+fn echo(command: &Command) {
+    if command.args.len() > 1 {
+        kprint!("{}", command.args[1]);
+        if command.args.len() > 2 {
+            for arg in &command.args[2..] {
+                kprint!(" {}", *arg);
+            }
+        }
+    }
+
+    kprintln!();
+}
+
+fn echohex(command: &Command) {
+    echo(&command);
+    if command.args.len() > 1 {
+        for byte in command.args[1].bytes() {
+            kprint!("{:02X}", byte);
+        }
+        if command.args.len() > 2 {
+            for arg in &command.args[2..] {
+                kprint!(" ");
+                for byte in arg.bytes() {
+                    kprint!("{:02X}", byte);
+                }
+            }
+        }
+    }
+    
+    kprintln!();
+}
+
+
+fn uptime(_command: &Command) {
+    let time = current_time();
+    let sec = time / 1000 / 1000;
+    let min = sec / 60;
+    let hour = min / 60;
+    let day = hour / 24;
+    kprintln!("Uptime: {} day(s), {:02}:{:02}:{:02}", day, hour % 24, min % 60, sec % 60);
+}
+
+fn exit(_command: &Command) -> ! {
+    // in line with bootloader
+    const BOOTLOADER_START_ADDR: usize = 0x4000000;
+    unsafe {
+        asm!("br $0" : : "r"(BOOTLOADER_START_ADDR));
+        loop {
+            asm!("nop" :::: "volatile")
+        }
+    }
 }
diff --git a/pi/src/gpio.rs b/pi/src/gpio.rs
index 92f4233..0ad6b96 100644
--- a/pi/src/gpio.rs
+++ b/pi/src/gpio.rs
@@ -102,7 +102,8 @@ impl Gpio<Uninitialized> {
     /// Enables the alternative function `function` for `self`. Consumes self
     /// and returns a `Gpio` structure in the `Alt` state.
     pub fn into_alt(self, function: Function) -> Gpio<Alt> {
-        unimplemented!()
+        self.registers.FSEL[(self.pin / 10) as usize].or_mask((function as u32) << (3 * (self.pin % 10)));
+        self.transition()
     }
 
     /// Sets this pin to be an _output_ pin. Consumes self and returns a `Gpio`
@@ -121,12 +122,12 @@ impl Gpio<Uninitialized> {
 impl Gpio<Output> {
     /// Sets (turns on) the pin.
     pub fn set(&mut self) {
-        unimplemented!()
+        self.registers.SET[(self.pin / 32) as usize].write(1 << (self.pin % 32));
     }
 
     /// Clears (turns off) the pin.
     pub fn clear(&mut self) {
-        unimplemented!()
+        self.registers.CLR[(self.pin / 32) as usize].write(1 << (self.pin % 32));
     }
 }
 
@@ -134,6 +135,6 @@ impl Gpio<Input> {
     /// Reads the pin's value. Returns `true` if the level is high and `false`
     /// if the level is low.
     pub fn level(&mut self) -> bool {
-        unimplemented!()
+        self.registers.LEV[(self.pin / 32) as usize].has_mask(1 << (self.pin % 32))
     }
 }
diff --git a/pi/src/lib.rs b/pi/src/lib.rs
index c30b1c2..48fccf8 100644
--- a/pi/src/lib.rs
+++ b/pi/src/lib.rs
@@ -2,7 +2,6 @@
 #![feature(const_fn)]
 #![feature(asm)]
 #![feature(decl_macro)]
-#![feature(repr_align)]
 #![feature(attr_literals)]
 #![feature(never_type)]
 
diff --git a/pi/src/timer.rs b/pi/src/timer.rs
index e0aa184..db60af2 100644
--- a/pi/src/timer.rs
+++ b/pi/src/timer.rs
@@ -30,21 +30,29 @@ impl Timer {
     /// Reads the system timer's counter and returns the 64-bit counter value.
     /// The returned value is the number of elapsed microseconds.
     pub fn read(&self) -> u64 {
-        unimplemented!()
+        let low = self.registers.CLO.read();
+        let high = self.registers.CHI.read();
+        ((high as u64) << 32) | (low as u64)
     }
 }
 
 /// Returns the current time in microseconds.
 pub fn current_time() -> u64 {
-    unimplemented!()
+    Timer::new().read()
 }
 
 /// Spins until `us` microseconds have passed.
 pub fn spin_sleep_us(us: u64) {
-    unimplemented!()
+    let old = current_time();
+    loop {
+        let new = current_time();
+        if old + us <= new {
+            break;
+        }
+    }
 }
 
 /// Spins until `ms` milliseconds have passed.
 pub fn spin_sleep_ms(ms: u64) {
-    unimplemented!()
+    spin_sleep_us(ms * 1000);
 }
diff --git a/pi/src/uart.rs b/pi/src/uart.rs
index 92b6159..4d00b59 100644
--- a/pi/src/uart.rs
+++ b/pi/src/uart.rs
@@ -24,6 +24,26 @@ enum LsrStatus {
 #[allow(non_snake_case)]
 struct Registers {
     // FIXME: Declare the "MU" registers from page 8.
+    AUX_MU_IO_REG: Volatile<u8>,
+    __r0: [Reserved<u8>; 3],
+    AUX_MU_IER_REG: Volatile<u8>,
+    __r1: [Reserved<u8>; 3],
+    AUX_MU_IIR_REG: Volatile<u8>,
+    __r2: [Reserved<u8>; 3],
+    AUX_MU_LCR_REG: Volatile<u8>,
+    __r3: [Reserved<u8>; 3],
+    AUX_MU_MCR_REG: Volatile<u8>,
+    __r4: [Reserved<u8>; 3],
+    AUX_MU_LSR_REG: ReadVolatile<u8>,
+    __r5: [Reserved<u8>; 3],
+    AUX_MU_MSR_REG: ReadVolatile<u8>,
+    __r6: [Reserved<u8>; 3],
+    AUX_MU_SCRATCH: Volatile<u8>,
+    __r7: [Reserved<u8>; 3],
+    AUX_MU_CNTL_REG: Volatile<u8>,
+    __r8: [Reserved<u8>; 3],
+    AUX_MU_STAT_REG: ReadVolatile<u32>,
+    AUX_MU_BAUD: Volatile<u16>
 }
 
 /// The Raspberry Pi's "mini UART".
@@ -46,27 +66,41 @@ impl MiniUart {
             (*AUX_ENABLES).or_mask(1);
             &mut *(MU_REG_BASE as *mut Registers)
         };
-
+        
         // FIXME: Implement remaining mini UART initialization.
-        unimplemented!()
+        // GPIO 14 15 set to TX/RX
+        Gpio::new(14).into_alt(Function::Alt5);
+        Gpio::new(15).into_alt(Function::Alt5);
+        registers.AUX_MU_LCR_REG.or_mask(0b11); // 8-bit data size
+        // baudrate = system_clock_freq / (8 * (baud_reg + 1))
+        // system_clock_freq is 250MHz (Page 10)
+        // 250MHz / 8 / 115200 - 1 = 270
+        registers.AUX_MU_BAUD.write(270); // 16-bit baudrate register
+        registers.AUX_MU_CNTL_REG.or_mask(0b11); // enable TX & RX
+
+        MiniUart {
+            registers: registers,
+            timeout: None,
+        }
     }
 
     /// Set the read timeout to `milliseconds` milliseconds.
     pub fn set_read_timeout(&mut self, milliseconds: u32) {
-        unimplemented!()
+        self.timeout = Some(milliseconds)
     }
 
     /// Write the byte `byte`. This method blocks until there is space available
     /// in the output FIFO.
     pub fn write_byte(&mut self, byte: u8) {
-        unimplemented!()
+        while !self.registers.AUX_MU_LSR_REG.has_mask(LsrStatus::TxAvailable as u8) { };
+        self.registers.AUX_MU_IO_REG.write(byte);
     }
 
     /// Returns `true` if there is at least one byte ready to be read. If this
     /// method returns `true`, a subsequent call to `read_byte` is guaranteed to
     /// return immediately. This method does not block.
     pub fn has_byte(&self) -> bool {
-        unimplemented!()
+        self.registers.AUX_MU_LSR_REG.has_mask(LsrStatus::DataReady as u8)
     }
 
     /// Blocks until there is a byte ready to read. If a read timeout is set,
@@ -78,17 +112,50 @@ impl MiniUart {
     /// returns `Ok(())`, a subsequent call to `read_byte` is guaranteed to
     /// return immediately.
     pub fn wait_for_byte(&self) -> Result<(), ()> {
-        unimplemented!()
+        match self.timeout {
+            None => {
+                loop {
+                    if self.has_byte() {
+                        return Ok(())
+                    }
+                }
+            },
+            Some(timeout) => {
+                let old = timer::current_time();
+                let deadline = old + (timeout as u64) * 1000; // Internal clock unit is microsecond, but timeout unit is millisecond
+                while deadline >= timer::current_time() {
+                    if self.has_byte() {
+                        return Ok(())
+                    }
+                }
+                Err(())
+            }
+        }
     }
 
     /// Reads a byte. Blocks indefinitely until a byte is ready to be read.
     pub fn read_byte(&mut self) -> u8 {
-        unimplemented!()
+        while !self.has_byte() { }
+        self.registers.AUX_MU_IO_REG.read()
     }
 }
 
 // FIXME: Implement `fmt::Write` for `MiniUart`. A b'\r' byte should be written
 // before writing any b'\n' byte.
+impl fmt::Write for MiniUart {
+    fn write_str(&mut self, s: &str) -> fmt::Result {
+        for byte in s.bytes() {
+            match byte {
+                b'\n' => {
+                    self.write_byte(b'\r');
+                    self.write_byte(b'\n');
+                },
+                _ => self.write_byte(byte)
+            }
+        }
+        Ok(())
+    }
+}
 
 #[cfg(feature = "std")]
 mod uart_io {
@@ -104,4 +171,34 @@ mod uart_io {
     //
     // The `io::Write::write()` method must write all of the requested bytes
     // before returning.
+    impl io::Read for MiniUart {
+       fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
+           match self.wait_for_byte() {
+               Ok(()) => {
+                   let mut index = 0;
+                   while self.has_byte() && index < buf.len() {
+                       buf[index] = self.read_byte();
+                       index += 1;
+                   }
+                   Ok(index)
+               },
+               Err(()) => {
+                   Err(io::Error::new(io::ErrorKind::TimedOut, "reading UART timed out"))
+               }
+           }
+       }
+    }
+
+    impl io::Write for MiniUart {
+       fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
+           for byte in buf {
+               self.write_byte(*byte);
+           }
+           Ok(buf.len())
+       }
+
+       fn flush(&mut self) -> io::Result<()> {
+           unimplemented!()
+       }
+    }
 }
