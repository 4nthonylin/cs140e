diff --git a/kernel/src/console.rs b/kernel/src/console.rs
index 9a78db0..143a45d 100644
--- a/kernel/src/console.rs
+++ b/kernel/src/console.rs
@@ -19,35 +19,36 @@ impl Console {
     /// Initializes the console if it's not already initialized.
     #[inline]
     fn initialize(&mut self) {
-        unimplemented!()
+        self.inner.get_or_insert_with(&MiniUart::new);
     }
 
     /// Returns a mutable borrow to the inner `MiniUart`, initializing it as
     /// needed.
     fn inner(&mut self) -> &mut MiniUart {
-        unimplemented!()
+        self.initialize();
+        self.inner.as_mut().unwrap()
     }
 
     /// Reads a byte from the UART device, blocking until a byte is available.
     pub fn read_byte(&mut self) -> u8 {
-        unimplemented!()
+        self.inner().read_byte()
     }
 
     /// Writes the byte `byte` to the UART device.
     pub fn write_byte(&mut self, byte: u8) {
-        unimplemented!()
+        self.inner().write_byte(byte)
     }
 }
 
 impl io::Read for Console {
     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
-        unimplemented!()
+        self.inner().read(buf)
     }
 }
 
 impl io::Write for Console {
     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
-        unimplemented!()
+        self.inner().write(buf)
     }
 
     fn flush(&mut self) -> io::Result<()> {
@@ -57,7 +58,7 @@ impl io::Write for Console {
 
 impl fmt::Write for Console {
     fn write_str(&mut self, s: &str) -> fmt::Result {
-        unimplemented!()
+        self.inner().write_str(s)
     }
 }
 
diff --git a/kernel/src/kmain.rs b/kernel/src/kmain.rs
index 9eacec9..f0171e5 100644
--- a/kernel/src/kmain.rs
+++ b/kernel/src/kmain.rs
@@ -12,12 +12,51 @@
 extern crate pi;
 extern crate stack_vec;
 
+use pi::gpio::Gpio;
+use std::fmt::Write;
+use pi::uart::MiniUart;
+use pi::timer::spin_sleep_ms;
+use pi::timer::current_time;
+
 pub mod lang_items;
 pub mod mutex;
 pub mod console;
 pub mod shell;
 
+use console::kprintln;
+
+fn blinky() {
+    let mut pin16 = Gpio::new(16);
+    let mut pin_out16 = pin16.into_output();
+
+    loop {
+        pin_out16.set();
+        spin_sleep_ms(1000);
+        pin_out16.clear();
+        spin_sleep_ms(1000);
+    }
+}
+
+fn echo() {
+    let mut uart = MiniUart::new();
+
+    loop {
+        let byte = uart.read_byte();
+        uart.write_byte(byte);
+    }
+}
+
+fn time() {
+    loop {
+        kprintln!("Current time: {}", current_time());
+        spin_sleep_ms(1000);
+    }
+}
+
 #[no_mangle]
 pub extern "C" fn kmain() {
     // FIXME: Start the shell.
+    // blinky();
+    // echo();
+    time();
 }
diff --git a/pi/src/gpio.rs b/pi/src/gpio.rs
index 92f4233..0ad6b96 100644
--- a/pi/src/gpio.rs
+++ b/pi/src/gpio.rs
@@ -102,7 +102,8 @@ impl Gpio<Uninitialized> {
     /// Enables the alternative function `function` for `self`. Consumes self
     /// and returns a `Gpio` structure in the `Alt` state.
     pub fn into_alt(self, function: Function) -> Gpio<Alt> {
-        unimplemented!()
+        self.registers.FSEL[(self.pin / 10) as usize].or_mask((function as u32) << (3 * (self.pin % 10)));
+        self.transition()
     }
 
     /// Sets this pin to be an _output_ pin. Consumes self and returns a `Gpio`
@@ -121,12 +122,12 @@ impl Gpio<Uninitialized> {
 impl Gpio<Output> {
     /// Sets (turns on) the pin.
     pub fn set(&mut self) {
-        unimplemented!()
+        self.registers.SET[(self.pin / 32) as usize].write(1 << (self.pin % 32));
     }
 
     /// Clears (turns off) the pin.
     pub fn clear(&mut self) {
-        unimplemented!()
+        self.registers.CLR[(self.pin / 32) as usize].write(1 << (self.pin % 32));
     }
 }
 
@@ -134,6 +135,6 @@ impl Gpio<Input> {
     /// Reads the pin's value. Returns `true` if the level is high and `false`
     /// if the level is low.
     pub fn level(&mut self) -> bool {
-        unimplemented!()
+        self.registers.LEV[(self.pin / 32) as usize].has_mask(1 << (self.pin % 32))
     }
 }
diff --git a/pi/src/timer.rs b/pi/src/timer.rs
index e0aa184..db60af2 100644
--- a/pi/src/timer.rs
+++ b/pi/src/timer.rs
@@ -30,21 +30,29 @@ impl Timer {
     /// Reads the system timer's counter and returns the 64-bit counter value.
     /// The returned value is the number of elapsed microseconds.
     pub fn read(&self) -> u64 {
-        unimplemented!()
+        let low = self.registers.CLO.read();
+        let high = self.registers.CHI.read();
+        ((high as u64) << 32) | (low as u64)
     }
 }
 
 /// Returns the current time in microseconds.
 pub fn current_time() -> u64 {
-    unimplemented!()
+    Timer::new().read()
 }
 
 /// Spins until `us` microseconds have passed.
 pub fn spin_sleep_us(us: u64) {
-    unimplemented!()
+    let old = current_time();
+    loop {
+        let new = current_time();
+        if old + us <= new {
+            break;
+        }
+    }
 }
 
 /// Spins until `ms` milliseconds have passed.
 pub fn spin_sleep_ms(ms: u64) {
-    unimplemented!()
+    spin_sleep_us(ms * 1000);
 }
diff --git a/pi/src/uart.rs b/pi/src/uart.rs
index 92b6159..ed35b66 100644
--- a/pi/src/uart.rs
+++ b/pi/src/uart.rs
@@ -24,6 +24,26 @@ enum LsrStatus {
 #[allow(non_snake_case)]
 struct Registers {
     // FIXME: Declare the "MU" registers from page 8.
+    AUX_MU_IO_REG: Volatile<u8>,
+    __r0: [Reserved<u8>; 3],
+    AUX_MU_IER_REG: Volatile<u8>,
+    __r1: [Reserved<u8>; 3],
+    AUX_MU_IIR_REG: Volatile<u8>,
+    __r2: [Reserved<u8>; 3],
+    AUX_MU_LCR_REG: Volatile<u8>,
+    __r3: [Reserved<u8>; 3],
+    AUX_MU_MCR_REG: Volatile<u8>,
+    __r4: [Reserved<u8>; 3],
+    AUX_MU_LSR_REG: ReadVolatile<u8>,
+    __r5: [Reserved<u8>; 3],
+    AUX_MU_MSR_REG: ReadVolatile<u8>,
+    __r6: [Reserved<u8>; 3],
+    AUX_MU_SCRATCH: Volatile<u8>,
+    __r7: [Reserved<u8>; 3],
+    AUX_MU_CNTL_REG: Volatile<u8>,
+    __r8: [Reserved<u8>; 3],
+    AUX_MU_STAT_REG: ReadVolatile<u32>,
+    AUX_MU_BAUD: Volatile<u16>
 }
 
 /// The Raspberry Pi's "mini UART".
@@ -46,27 +66,41 @@ impl MiniUart {
             (*AUX_ENABLES).or_mask(1);
             &mut *(MU_REG_BASE as *mut Registers)
         };
-
+        
         // FIXME: Implement remaining mini UART initialization.
-        unimplemented!()
+        // GPIO 14 15 set to TX/RX
+        Gpio::new(14).into_alt(Function::Alt5);
+        Gpio::new(15).into_alt(Function::Alt5);
+        registers.AUX_MU_LCR_REG.or_mask(0b11); // 8-bit data size
+        // baudrate = system_clock_freq / (8 * (baud_reg + 1))
+        // system_clock_freq is 250MHz (Page 10)
+        // 250MHz / 8 / 115200 - 1 = 270
+        registers.AUX_MU_BAUD.write(270); // 16-bit baudrate register
+        registers.AUX_MU_CNTL_REG.or_mask(0b11); // enable TX & RX
+
+        MiniUart {
+            registers: registers,
+            timeout: None,
+        }
     }
 
     /// Set the read timeout to `milliseconds` milliseconds.
     pub fn set_read_timeout(&mut self, milliseconds: u32) {
-        unimplemented!()
+        self.timeout = Some(milliseconds)
     }
 
     /// Write the byte `byte`. This method blocks until there is space available
     /// in the output FIFO.
     pub fn write_byte(&mut self, byte: u8) {
-        unimplemented!()
+        while !self.registers.AUX_MU_LSR_REG.has_mask(LsrStatus::TxAvailable as u8) { };
+        self.registers.AUX_MU_IO_REG.write(byte);
     }
 
     /// Returns `true` if there is at least one byte ready to be read. If this
     /// method returns `true`, a subsequent call to `read_byte` is guaranteed to
     /// return immediately. This method does not block.
     pub fn has_byte(&self) -> bool {
-        unimplemented!()
+        self.registers.AUX_MU_LSR_REG.has_mask(LsrStatus::DataReady as u8)
     }
 
     /// Blocks until there is a byte ready to read. If a read timeout is set,
@@ -78,17 +112,50 @@ impl MiniUart {
     /// returns `Ok(())`, a subsequent call to `read_byte` is guaranteed to
     /// return immediately.
     pub fn wait_for_byte(&self) -> Result<(), ()> {
-        unimplemented!()
+        match self.timeout {
+            None => {
+                loop {
+                    if self.has_byte() {
+                        return Ok(())
+                    }
+                }
+            },
+            Some(timeout) => {
+                let old = timer::current_time();
+                let deadline = old + timeout as u64;
+                while deadline >= timer::current_time() {
+                    if self.has_byte() {
+                        return Ok(())
+                    }
+                }
+                Err(())
+            }
+        }
     }
 
     /// Reads a byte. Blocks indefinitely until a byte is ready to be read.
     pub fn read_byte(&mut self) -> u8 {
-        unimplemented!()
+        while !self.has_byte() { }
+        self.registers.AUX_MU_IO_REG.read()
     }
 }
 
 // FIXME: Implement `fmt::Write` for `MiniUart`. A b'\r' byte should be written
 // before writing any b'\n' byte.
+impl fmt::Write for MiniUart {
+    fn write_str(&mut self, s: &str) -> fmt::Result {
+        for byte in s.bytes() {
+            match byte {
+                b'\n' => {
+                    self.write_byte(b'\r');
+                    self.write_byte(b'\n');
+                },
+                _ => self.write_byte(byte)
+            }
+        }
+        Ok(())
+    }
+}
 
 #[cfg(feature = "std")]
 mod uart_io {
@@ -104,4 +171,33 @@ mod uart_io {
     //
     // The `io::Write::write()` method must write all of the requested bytes
     // before returning.
+    impl io::Read for MiniUart {
+       fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
+           match self.wait_for_byte() {
+               Ok(()) => {
+                   let index = 0;
+                   while self.has_byte() && index < buf.len() {
+                       buf[index] = self.read_byte()
+                   }
+                   Ok(index)
+               },
+               Err(()) => {
+                   Err(io::Error::new(io::ErrorKind::TimedOut, "reading UART timed out"))
+               }
+           }
+       }
+    }
+
+    impl io::Write for MiniUart {
+       fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
+           for byte in buf {
+               self.write_byte(*byte);
+           }
+           Ok(buf.len())
+       }
+
+       fn flush(&mut self) -> io::Result<()> {
+           unimplemented!()
+       }
+    }
 }
